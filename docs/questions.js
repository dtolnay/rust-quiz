var questions = {
  "0": {
    "code": "use std::rc::Rc;\n\nstruct A;\n\nfn d<T>(t: T) {\n    match std::mem::size_of_val(&t) {\n        0 => print!(\"0\"),\n        _ => print!(\"1\"),\n    }\n}\n\nfn main() {\n    let a = &A;\n    d(a);\n    d(a.clone());\n    \n    let b = &();\n    d(b);\n    d(b.clone());\n    \n    let c = Rc::new(());\n    d(Rc::clone(&c));\n    d(c.clone());\n}\n",
    "difficulty": 1,
    "answer": "111011",
    "hint": "<p>Immutable pointers <code>&amp;T</code> and <code>Rc&lt;T&gt;</code> implement <code>Clone</code> even if <code>T</code> doesn't.</p>\n",
    "explanation": "<p>Both of our non-reference types, <code>()</code> and <code>A</code>, are zero-sized so, for our\npurposes, the function <code>d</code> will print <code>0</code> for dereferenced values and <code>1</code> for\npointers, regardless of their size.</p>\n<p><code>d(a)</code> prints <code>1</code> because <code>a</code> is a reference. <code>A</code> does not implement <code>Clone</code>\nbut there is a blanket implementation for <code>&amp;T</code> which just clones the reference.\n<code>d(a.clone())</code> will therefore print <code>1</code> too.</p>\n<p>The type <code>()</code> <em>does</em> implement <code>Clone</code>, so <code>b.clone()</code> returns a <code>()</code>, not a\n<code>&amp;()</code>. <code>b</code> is still a reference so <code>d(b)</code> prints <code>1</code>, but <code>d(b.clone())</code> prints\n<code>0</code> since <code>()</code> is zero-sized.</p>\n<p>It's considered idiomatic to clone a <code>Rc</code> using <code>Rc::clone(&amp;c)</code> instead of\n<code>c.clone()</code>, because it makes it clearer that you cloning the pointer and not\nthe underlying data. However, these are exactly the same function! In both cases\nwe clone the <code>Rc</code> and <code>d</code> prints <code>1</code>. To call the <code>clone</code> method of a value\ninside a <code>Rc</code>, you need to dereference it first: <code>(*c).clone()</code>.</p>\n"
  },
  "1": {
    "code": "macro_rules! m {\n    ($($s:stmt)*) => {\n        $(\n            { stringify!($s); 1 }\n        )<<*\n    };\n}\n\nfn main() {\n    print!(\n        \"{}{}{}\",\n        m! { return || true },\n        m! { (return) || true },\n        m! { {return} || true },\n    );\n}\n",
    "difficulty": 3,
    "answer": "112",
    "hint": "<p>The expression in the output of the macro evaluates to the same value as <code>1 &lt;&lt; (n - 1)</code> where <code>n</code> is the number of statements contained in the macro input.</p>\n",
    "explanation": "<p>This question revolves around where the Rust grammar places statement\nboundaries.</p>\n<p>The input rule of the macro <code>m!</code> is <code>$($s:stmt)*</code> which matches zero or more\nRust statements. The <code>$(</code>...<code>)*</code> part of the rule is a <em>repetition</em> which\nmatches the contents of the repetition zero or more times, and the <code>$s:stmt</code> is\na fragment specifier that matches a Rust statement (<code>stmt</code>) conforming to the\nrules of the Rust grammar. The matched statements are available within the\nexpanded code as the fragment variable <code>$s</code>.</p>\n<p>A <em>statement</em> is the top-level unit of syntax permitted within a function body.\nAll of the following are examples of statements. The grammar of function bodies\nrequires that some types of statements are followed by a semicolon, but the\nsemicolon is not part of the statement for the purpose of macro syntax.</p>\n<pre><code class=\"language-rust\">// Items are statements.\nstruct S { x: u64 }\n\n// Let-bindings are statements.\nlet mut s = S { x: 1 }\n\n// Expressions are statements.\ns.x + 1\n</code></pre>\n<p>The macro <code>m!</code> expands to zero or more copies of <code>{ stringify!($s); 1 }</code>\nseparated by the <code>&lt;&lt;</code> token. The <code>$(</code>...<code>)&lt;&lt;*</code> part of the rule is a repetition\nusing <code>&lt;&lt;</code> as the separator.</p>\n<p>Using <code>&lt;&lt;</code> as a separator in a repetition in a macro is highly unusual. The most\ncommmonly used separator is the comma, written as <code>$(</code>...<code>),*</code>, but any other\nsingle token is allowed here. Crucially, <code>macro_rules!</code> treats all built-in Rust\noperators as single tokens, even those that consist of multiple characters like\n<code>&lt;&lt;</code>.</p>\n<p>The <code>{ stringify!($s); 1 }</code> is an expression whose value is always 1. The value\nof <code>stringify!($s)</code> is discarded, so this is equivalent to the expression <code>{ 1 }</code>. The reason for having <code>stringify!($s)</code> in there is to control the number of\ntimes the repetition is repeated, which is determined by which fragment\nvariables are used within the repetition. Writing a repetition without using any\nfragment variables inside of it would not be legal.</p>\n<p>Suppose we call this macro with three of the statements shown above as input.</p>\n<pre><code class=\"language-rust\">m! {\n    struct S { x: u64 }\n    let mut s = S { x: 1 }\n    s.x + 1\n}\n</code></pre>\n<p>The macro expands to:</p>\n<pre><code class=\"language-rust\">{ stringify!(struct S { x: u64 }); 1 }\n    &lt;&lt; { stringify!(let mut s = S { x: 1 }); 1 }\n    &lt;&lt; { stringify!(s.x + 1); 1 }\n</code></pre>\n<p>Each of the <code>stringify</code>s expands to a string literal:</p>\n<pre><code class=\"language-rust\">{ &quot;struct S { x: u64 }&quot;; 1 }\n    &lt;&lt; { &quot;let mut s = S { x: 1 }&quot;; 1 }\n    &lt;&lt; { &quot;s.x + 1&quot;; 1 }\n</code></pre>\n<p>The values of the string literals are not used. In this case the expression is\nequivalent to <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>, which is equivalent to <code>1 &lt;&lt; 1 &lt;&lt; 1</code>.\nThe <code>&lt;&lt;</code> operator is left-associative; the numeric value of this expression is\n4.</p>\n<p>Altogether, the relevant behavior of this macro is that it evaluates to <code>1 &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; ...</code> where the number of ones is equal to the number of Rust statements\nin the input of the macro. In closed form, the numeric value is <code>1 &lt;&lt; (n - 1)</code>\nwhere <code>n</code> is the number of statements, except in the case that <code>n</code> is zero where\nthe macro expands to nothing and we get a syntax error at the call site.</p>\n<p>It remains to determine how many statements are in the three invocations of\n<code>m!</code> in the quiz code.</p>\n<ol>\n<li>\n<p><code>return || true</code></p>\n<p>This is a return-expression that would return the closure <code>|| true</code>. It is\nequivalent to <code>return (|| true)</code>. It is parsed as a single statement so the\n<code>m!</code> invocation evaluates to <code>1</code>.</p>\n</li>\n<li>\n<p><code>(return) || true</code></p>\n<p>This is a logical-OR expression. The <code>||</code> is a binary operator, where the\nleft-hand side is the expression <code>(return)</code> (of diverging type <code>!</code>) and the\nright-hand side is the expression <code>true</code>. This expression is a single\nstatement so <code>m!</code> again evaluates to <code>1</code>.</p>\n</li>\n<li>\n<p><code>{return} || true</code></p>\n<p>This one is two statements! A block-statement <code>{return}</code> followed by a\nclosure expression <code>|| true</code>.</p>\n<p>The Rust grammar distinguishes between expressions that require a semicolon\nin order to stand alone as a statement, and expressions that can be\nstatements even without a semicolon. Consider two examples:</p>\n<pre><code class=\"language-rust\">// No trailing semicolon required.\nfor t in vec {\n    /* ... */\n}\n\n// Trailing semicolon required.\nself.skip_whitespace()?;\n</code></pre>\n<p>The list of expression types that stand alone without a semicolon is defined\n<a target=\"_blank\" href=\"https://github.com/rust-lang/rust/blob/1.30.1/src/libsyntax/parse/classify.rs#L17-L37\">here</a> in libsyntax. The distinction informs a few different early\nbail-out cases where the parser decides to finish parsing the current\nexpression.</p>\n<p>Relevant to our case is that block expressions <code>{ /* ... */ }</code> terminate an\nexpression if doing so would be syntactically sensible. The parser does not\neagerly consume binary operators after a block expression. Thus one might\nwrite:</p>\n<pre><code class=\"language-rust\">fn f() -&gt; &amp;'static &amp;'static bool {\n    // Block expression.\n    {\n        println!(&quot;What a silly function.&quot;);\n    }\n\n    // Reference to reference to true.\n    &amp;&amp;true\n}\n</code></pre>\n<p>In order to parse a block followed by a binary operator, we would need to\nmake it syntactically insensible for the parser to terminate an expression\nat the close curly brace. This would usually be done by wrapping in\nparentheses.</p>\n<pre><code class=\"language-rust\">fn f() -&gt; bool {\n    ({ true } &amp;&amp; true)\n}\n</code></pre>\n</li>\n</ol>\n<p>Anyhow, the output of the program is <code>112</code>.</p>\n"
  },
  "2": {
    "code": "struct S(i32);\n\nimpl std::ops::BitAnd<S> for () {\n    type Output = ();\n\n    fn bitand(self, rhs: S) {\n        print!(\"{}\", rhs.0);\n    }\n}\n\nfn main() {\n    let f = || ( () & S(1) );\n    let g = || { () & S(2) };\n    let h = || ( {} & S(3) );\n    let i = || { {} & S(4) };\n    f();\n    g();\n    h();\n    i();\n}\n",
    "difficulty": 2,
    "answer": "123",
    "hint": "<p>One of these four closures is unlike the other three.</p>\n",
    "explanation": "<p>The closures <code>f</code>, <code>g</code>, and <code>h</code> are all of type <code>impl Fn()</code>. The closure bodies\nare parsed as an invocation of the user-defined bitwise-AND operator defined\nabove by the <code>BitAnd</code> trait impl. When the closures are invoked, the bitwise-AND\nimplementation prints the content of the <code>S</code> from the right-hand side and\nevaluates to <code>()</code>.</p>\n<p>The closure <code>i</code> is different. Formatting the code with rustfmt makes it clearer\nhow <code>i</code> is parsed.</p>\n<pre><code class=\"language-rust\">let i = || {\n    {}\n    &amp;S(4)\n};\n</code></pre>\n<p>The closure body consists of an empty block-statement <code>{}</code> followed by a\n<em>reference</em> to <code>S(4)</code>, not a bitwise-AND. The type of <code>i</code> is <code>impl Fn() -&gt; &amp;'static S</code>.</p>\n<p>The parsing of this case is governed by <a target=\"_blank\" href=\"https://github.com/rust-lang/rust/blob/1.30.1/src/libsyntax/parse/classify.rs#L17-L37\">this code</a> in libsyntax.</p>\n"
  },
  "3": {
    "code": "struct S {\n    x: i32,\n}\n\nconst S: S = S { x: 2 };\n\nfn main() {\n    let v = &mut S;\n    v.x += 1;\n    S.x += 1;\n    print!(\"{}{}\", v.x, S.x);\n}\n",
    "difficulty": 1,
    "answer": "32",
    "hint": "<p>In what ways is a <code>const</code> different from a non-mut <code>static</code>?</p>\n",
    "explanation": "<p>The semantics of <code>const</code> is that any mention of the <code>const</code> by name in\nexpression position is substituted with the value of the <code>const</code> initializer. In\nthis quiz code the behavior is equivalent to:</p>\n<pre><code class=\"language-rust\">struct S {\n    x: i32,\n}\n\nfn main() {\n    let v = &amp;mut S { x: 2 };\n    v.x += 1;\n    S { x: 2 }.x += 1;\n    print!(&quot;{}{}&quot;, v.x, S { x: 2 }.x);\n}\n</code></pre>\n<p>I have simply substituted every mention of <code>S</code> in expresson position with the\nvalue of <code>const S</code> which is <code>S { x: 2 }</code>.</p>\n<p>The first line of <code>main</code> is equivalent to:</p>\n<pre><code class=\"language-rust\">let mut _tmp0 = S { x: 2 };\nlet v = &amp;mut _tmp0;\n</code></pre>\n<p>The second line of <code>main</code> mutates the value pointed to by <code>v</code>. The same value\nremains accessible through <code>v</code> for the rest of the lifetime of <code>v</code>, which is why\nthe first character printed is <code>3</code>.</p>\n<p>The third line of <code>main</code> mutates a temporary that immediately goes out of scope\nat the semicolon. The second character printed is coming from a brand new <code>S { x: 2 }</code>, so <code>2</code> is printed.</p>\n<p>One additional wrinkle in this code is the concept of namespaces and name\nresolution in Rust. Any name that refers to a <em>type</em> lives in the <em>type\nnamespace</em>, and any name that refers to a <em>value</em> lives in the <em>value\nnamespace</em>. These are two separate sets of names, and the language is structured\nsuch that we can always tell which namespace to look up a name in.</p>\n<p>In the context of the quiz code, the name of the struct <code>S</code> is part of the type\nnamespace and the name of the const <code>S</code> is part of the value namespace. That is\nhow we can have seemingly two different things with the same name in scope at\nthe same time.</p>\n"
  },
  "4": {
    "code": "fn main() {\n    let (.., x, y) = (0, 1, ..);\n    print!(\"{}\", b\"066\"[y][x]);\n}\n",
    "difficulty": 1,
    "answer": "54",
    "hint": "<p><code>..</code> means one thing in an expression and something else in a pattern.</p>\n",
    "explanation": "<p>This question demonstrates two different meanings of <code>..</code>.</p>\n<p>In expression position, <code>..</code> is the syntax for constructing various types of\nranges. Here the expression <code>(0, 1, ..)</code> is a tuple with three elements, the\nthird one having type <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/ops/struct.RangeFull.html\"><code>RangeFull</code></a>.</p>\n<p>On the other hand in a pattern, <code>..</code> is used to mean &quot;any number of elements&quot;.\nSo the pattern <code>(.., x, y)</code> matches a tuple with 2 or more elements, binding the\nsecond-last one to <code>x</code> and the last one to <code>y</code>.</p>\n<p>Coming out of the first line of <code>main</code>, we have <code>x = 1</code> and <code>y = (..)</code>. Thus the\nvalue printed is going to be <code>b&quot;066&quot;[..][1]</code>.</p>\n<p>The expression <code>b&quot;066&quot;</code> is a byte-string literal of type <code>&amp;'static [u8; 3]</code>\ncontaining the three ASCII bytes <code>b'0'</code>, <code>b'6'</code>, <code>b'6'</code>.</p>\n<p>When we slice the byte-string with <code>RangeFull</code> we get a dynamically sized slice\n<code>[u8]</code> of length 3. Next we access element <code>1</code> of the slice, which is the byte\n<code>b'6'</code> of type <code>u8</code>. When printed, we see the decimal representation of the byte\nvalue of the ASCII digit 6, which is the number 54.</p>\n"
  },
  "5": {
    "code": "trait Trait {\n    fn p(self);\n}\n\nimpl<T> Trait for fn(T) {\n    fn p(self) {\n        print!(\"1\");\n    }\n}\n\nimpl<T> Trait for fn(&T) {\n    fn p(self) {\n        print!(\"2\");\n    }\n}\n\nfn f(_: u8) {}\nfn g(_: &u8) {}\n\nfn main() {\n    let a: fn(_) = f;\n    let b: fn(_) = g;\n    let c: fn(&_) = g;\n    a.p();\n    b.p();\n    c.p();\n}\n",
    "difficulty": 2,
    "answer": "112",
    "hint": "<p>If you are familiar with <a target=\"_blank\" href=\"https://doc.rust-lang.org/nomicon/hrtb.html\">higher-rank trait bound</a> syntax, try desugaring\nall the types in the impl signatures and types in <code>main</code> into their fully\nexplicit form.</p>\n",
    "explanation": "<p>The first impl applies to function pointers of type <code>fn(T)</code> where <code>T</code> is any\nsingle concrete type. The second impl applies to function pointers of\nhigher-ranked type <code>for&lt;'a&gt; fn(&amp;'a T)</code> for some concrete type <code>T</code> that outlives\n<code>'a</code>.</p>\n<p>Inside of <code>main</code>, the compiler is going to use type inference to substitute all\noccurrences of <code>_</code> in a type by some concrete type.</p>\n<p>For the closure <code>a</code> we infer <code>_ = u8</code>, yielding the closure type <code>fn(u8)</code> taking\nan argument of type <code>u8</code> and returning <code>()</code>.</p>\n<p>For <code>b</code> we infer <code>_ = &amp;'x u8</code> for some concrete lifetime <code>'x</code> that will\nultimately feed into the borrow checker. The type of <code>b</code> is <code>fn(&amp;'x u8)</code>.</p>\n<p>And finally for <code>c</code> we infer <code>_ = u8</code>, yielding the higher-ranked closure type\n<code>for&lt;'a&gt; fn(&amp;'a u8)</code>.</p>\n<p>Framed in this way, it follows that the trait method calls at the end of <code>main</code>\nprint <code>112</code>.</p>\n"
  },
  "6": {
    "code": "use std::mem;\n\nfn main() {\n    let a;\n    let a = a = true;\n    print!(\"{}\", mem::size_of_val(&a));\n}\n",
    "difficulty": 1,
    "answer": "0",
    "hint": "<p>There are two variables named <code>a</code>. What is the type of each one?</p>\n",
    "explanation": "<p>There are two variables named <code>a</code>, one shadowing the other. The program is\nequivalent to:</p>\n<pre><code class=\"language-rust\">let a;\nlet b = a = true;\nprint!(&quot;{}&quot;, mem::size_of_val(&amp;b));\n</code></pre>\n<p>Further, the value being assigned to <code>b</code> is the expression <code>a = true</code>.</p>\n<p>In Rust, assignment expressions always have the value <code>()</code>. Simplified some\nmore, the quiz code is equivalent to:</p>\n<pre><code class=\"language-rust\">let a = true;\nlet b = ();\nprint!(&quot;{}&quot;, mem::size_of_val(&amp;b));\n</code></pre>\n<p>Refer to the documentation of <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/mem/fn.size_of_val.html\"><code>size_of_val</code></a> for a specification of its\nbehavior, but in this case it is being instantiated with <code>T = ()</code> and we end up\nprinting the value of <code>size_of::&lt;()&gt;()</code>.</p>\n<p><code>()</code> is one example of a <a target=\"_blank\" href=\"https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\"><em>zero-sized type</em></a> or ZST and is represented by\nzero bytes of data at runtime, so the program prints <code>0</code>.</p>\n"
  },
  "7": {
    "code": "#[repr(u8)]\nenum Enum {\n    First,\n    Second,\n}\n\nimpl Enum {\n    fn p(self) {\n        match self {\n            First => print!(\"1\"),\n            Second => print!(\"2\"),\n        }\n    }\n}\n\nfn main() {\n    Enum::p(unsafe {\n        std::mem::transmute(1u8)\n    });\n}\n",
    "difficulty": 2,
    "answer": "1",
    "hint": "<p>The argument of the call to <code>Enum::p</code> is guaranteed to be <code>Enum::Second</code>.</p>\n",
    "explanation": "<p>Filling in the implicit discriminants, the definition of <code>Enum</code> is equivalent\nto:</p>\n<pre><code class=\"language-rust\">#[repr(u8)]\nenum Enum {\n    First = 0u8,\n    Second = 1u8,\n}\n</code></pre>\n<p>The unsafe transmute is a red herring. The attribute <code>#[repr(u8)]</code> guarantees\nthat our type has the same representation as <code>u8</code>, and the discriminant on\n<code>Enum::Second</code> guarantees that <code>Enum::Second</code> has the same representation as\n<code>1u8</code>. The transmute is well-defined and evaluates to <code>Enum::Second</code>.</p>\n<p>If the method <code>p</code> had been written as:</p>\n<pre><code class=\"language-rust\">match self {\n    Enum::First =&gt; print!(&quot;1&quot;),\n    Enum::Second =&gt; print!(&quot;2&quot;),\n}\n</code></pre>\n<p>then this program would print <code>2</code>.</p>\n<p>However, as written, both arms of the <code>match</code> expression are wildcard matches\nthat successfully match <em>any</em> value and bind a <em>variable</em> with the name <code>First</code>\nor <code>Second</code>. Match arms are applied in order so the wildcard match in the first\narm is always the one matched.</p>\n<p>The compiler helps us out with not one but two relevant warnings. First it\ndescribes exactly how this <code>match</code> is parsed and why that is probably silly.</p>\n<pre><code>warning: unreachable pattern\n  --&gt; questions/007.rs:11:13\n   |\n10 |             First =&gt; print!(&quot;1&quot;),\n   |             ----- matches any value\n11 |             Second =&gt; print!(&quot;2&quot;),\n   |             ^^^^^^ unreachable pattern\n</code></pre>\n<p>Second, it recognizes what the programmer has done wrong and what they probably\nmeant to write instead.</p>\n<pre><code>warning[E0170]: pattern binding `First` is named the same as one of the variants of the type `Enum`\n  --&gt; questions/007.rs:10:13\n   |\n10 |             First =&gt; print!(&quot;1&quot;),\n   |             ^^^^^ help: to match on the variant, qualify the path: `Enum::First`\n</code></pre>\n<p>An alternative to writing qualified paths in the pattern is to bring the\nvariants into scope.</p>\n<pre><code class=\"language-rust\">use Enum::*;\n\nmatch self {\n    First =&gt; print!(&quot;1&quot;),\n    Second =&gt; print!(&quot;2&quot;),\n}\n</code></pre>\n<p>Having variants brought into scope by the <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/prelude/index.html\">standard library prelude</a> is\nwhat allows us to write <code>Ok</code> and <code>Some</code> in match arms, rather than the qualified\npaths <code>Result::Ok</code> and <code>Option::Some</code>.</p>\n"
  },
  "8": {
    "code": "macro_rules! m {\n    (==>) => { print!(\"1\"); };\n    (= = >) => { print!(\"2\"); };\n    (== >) => { print!(\"3\"); };\n    (= =>) => { print!(\"4\"); };\n}\n\nfn main() {\n    m!(==>);\n    m!(= = >);\n    m!(== >);\n    m!(= =>);\n}\n",
    "difficulty": 2,
    "answer": "1214",
    "hint": "<p>According to <code>macro_rules!</code>, <code>==</code> is one token and <code>=&gt;</code> is one token.</p>\n",
    "explanation": "<p>Adjacent punctuation characters in the input pattern of a <code>macro_rules!</code> macro\nare grouped according to how those characters are used by native Rust tokens.</p>\n<p><a target=\"_blank\" href=\"https://docs.rs/syn/0.15.22/syn/token/index.html#structs\">This page</a> contains a list of the single-character and multi-character\npunctuation tokens involved in the Rust grammar.</p>\n<p>As one example from that list, <code>&lt;&lt;=</code> is a single token because the Rust grammar\nuses that sequence of characters to mean <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/ops/trait.ShlAssign.html\">left shift assignment</a>.\nThus a <code>macro_rules!</code> input rule containing <code>&lt;&lt;=</code> would only match if all three\ncharacters <code>&lt;&lt;=</code> are written consecutively without spaces in the invocation.</p>\n<p>But for example <code>=&lt;&lt;</code> is not a native token in the Rust grammar. The parser of\n<code>macro_rules!</code> will decompose this into Rust tokens according to a greedy\nprocess. <code>=&lt;</code> is also not a native token, so first we would need to match a <code>=</code>\nby itself. Then <code>&lt;&lt;</code> <em>is</em> a native token. Writing <code>=&lt;&lt;</code> in a macro rule behaves\nexactly the same as writing <code>= &lt;&lt;</code>.</p>\n<p>Now let's decompose the rules in the quiz code the same way.</p>\n<ul>\n<li><code>==&gt;</code> decomposes as <code>== &gt;</code>.</li>\n<li><code>= = &gt;</code> is already decomposed into Rust tokens.</li>\n<li><code>== &gt;</code> is already decomposed.</li>\n<li><code>= =&gt;</code> is already decomposed.</li>\n</ul>\n<p>Our macro is the same as if we had written the first rule with a space. The\nthird rule is unreachable.</p>\n<pre><code class=\"language-rust\">macro_rules! m {\n    (== &gt;) =&gt; { print!(&quot;1&quot;); };\n    (= = &gt;) =&gt; { print!(&quot;2&quot;); };\n    (== &gt;) =&gt; { print!(&quot;3&quot;); };\n    (= =&gt;) =&gt; { print!(&quot;4&quot;); };\n}\n</code></pre>\n<p>Within <code>main</code>, the first and third lines <em>both</em> match the first macro rule. The\nsecond line matches the second rule and the fourth line matches the fourth rule.\nThe output is <code>1214</code>.</p>\n<p><a target=\"_blank\" href=\"https://github.com/dtolnay/syn\">Procedural macros</a> use a more flexible and powerful macro API and can\nalways distinguish between different spacings of the same characters, such as\n<code>== &gt;</code> vs <code>==&gt;</code>.</p>\n"
  },
  "9": {
    "code": "macro_rules! m {\n    (1) => { print!(\"1\") };\n    ($tt:tt) => { print!(\"2\") };\n}\n\nmacro_rules! e {\n    ($e:expr) => { m!($e) };\n}\n\nmacro_rules! t {\n    ($tt:tt) => { e!($tt); m!($tt); };\n}\n\nfn main() {\n    t!(1);\n}\n",
    "difficulty": 2,
    "answer": "21",
    "hint": "<p>Upon being matched as a <code>$:expr</code>, the matched expression becomes a single opaque\ntoken tree.</p>\n",
    "explanation": "<p>This question involves the behavior of macro matchers as regards matching macro\nmetavariables.</p>\n<p>Starting from the bottom of the quiz code, the invocation <code>t!(1)</code> matches the\nfirst rule of <code>t!</code> and expands to <code>e!(1); m!(1);</code>.</p>\n<p>The invocation <code>e!(1)</code> matches the first rule of <code>e!</code>. As part of this match,\nthe expression <code>1</code> is packaged into an opaque expression token called <code>$e</code>. At\nno subsequent point will it be possible for any <code>macro_rules!</code> macro to look\ninside of <code>$e</code>. All that can be known is that <code>$e</code> is <em>some</em> expression.</p>\n<p>In any case, <code>e!(1)</code> expands to <code>m!($e)</code> where <code>$e</code> is an opaque expression\ncontaining <code>1</code>. That <code>m!($e)</code> <em>does not</em> match the first rule of <code>m!</code> because\n<code>$e</code> is opaque. Instead it matches the second rule of <code>m!</code> and prints <code>2</code>.</p>\n<p>After <code>e!(1)</code> there is an invocation <code>m!(1)</code> coming from the expansion of <code>t!</code>.\nThat one <em>does</em> match the first rule of <code>m!</code> and prints <code>1</code>. The output of this\nprogram is <code>21</code>.</p>\n<p>Most fragment specifiers have this behavior of becoming opaque token boxes, but\nsome do not. Specifiers that are opaque once matched:</p>\n<ul>\n<li><code>$:block</code></li>\n<li><code>$:expr</code></li>\n<li><code>$:item</code></li>\n<li><code>$:literal</code></li>\n<li><code>$:meta</code></li>\n<li><code>$:pat</code></li>\n<li><code>$:path</code></li>\n<li><code>$:stmt</code></li>\n<li><code>$:ty</code></li>\n</ul>\n<p>The rest of the specifiers do not become opaque and can be inspected by\nsubsequent rules:</p>\n<ul>\n<li><code>$:ident</code></li>\n<li><code>$:lifetime</code></li>\n<li><code>$:tt</code></li>\n</ul>\n<p>For example:</p>\n<pre><code class=\"language-rust\">macro_rules! m {\n    ('a) =&gt; {};\n}\n\nmacro_rules! l {\n    ($l:lifetime) =&gt; {\n        // $l is not opaque.\n        m!($l);\n    }\n}\n\nl!('a);\n</code></pre>\n"
  },
  "10": {
    "code": "trait Trait {\n    fn f(&self);\n}\n\nimpl<'a> dyn Trait + 'a {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for bool {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    Trait::f(&true);\n    Trait::f(&true as &dyn Trait);\n    <_ as Trait>::f(&true);\n    <_ as Trait>::f(&true as &dyn Trait);\n    <bool as Trait>::f(&true);\n}\n",
    "difficulty": 2,
    "answer": "22222",
    "hint": "<p>This won't help you answer the question but may help feel better: the quiz\nauthor was also stumped by this one.</p>\n",
    "explanation": "<p>This question contains a trait method <code>Trait::f</code> as well as an inherent method\n<code>f</code> on the trait object type <code>dyn Trait</code>.</p>\n<p><em>As far as I know,</em> given that these names shadow each other, the inherent\nmethod is literally uncallable. There is currently no syntax in Rust for calling\nthe inherent <code>f</code> on <code>dyn Trait</code>.</p>\n<p>If the trait method were named something different and only the inherent method\nwere called <code>f</code>, then the first two lines of <code>main</code> would successfully call the\ninherent method. However, as written with shadowed names, they disambiguate to\nthe trait method.</p>\n<p>One additional syntax to try would be:</p>\n<pre><code class=\"language-rust\">&lt;dyn Trait&gt;::f(&amp;true);\n&lt;dyn Trait&gt;::f(&amp;true as &amp;dyn Trait);\n</code></pre>\n<p>If the trait method were named something different, both of these would call the\ninherent method. If the inherent method were named something different, both of\nthese would call the trait method. But if the trait method and the inherent\nmethod are both <code>f</code> then the compiler reports an ambiguity.</p>\n<pre><code>error[E0034]: multiple applicable items in scope\n  --&gt; questions/010.rs:18:5\n   |\n18 |     &lt;dyn Trait&gt;::f(&amp;true);\n   |     ^^^^^^^^^^^^^^ multiple `f` found\n   |\nnote: candidate #1 is defined in an impl for the type `dyn Trait`\n  --&gt; questions/010.rs:6:5\n   |\n6  |     fn f(&amp;self) {\n   |     ^^^^^^^^^^^\nnote: candidate #2 is defined in the trait `Trait`\n  --&gt; questions/010.rs:2:5\n   |\n2  |     fn f(&amp;self);\n   |     ^^^^^^^^^^^^\n   = help: to disambiguate the method call, write `Trait::f(...)` instead\n</code></pre>\n<p>Maybe some day it will be possible to disambiguate a call to an inherent method\non a trait object shadowed by a trait method. For now, the quiz code prints\n<code>22222</code>.</p>\n"
  },
  "11": {
    "code": "fn f<'a>() {}\nfn g<'a: 'a>() {}\n\nfn main() {\n    let pf = f::<'static> as fn();\n    let pg = g::<'static> as fn();\n    print!(\"{}\", pf == pg);\n}\n",
    "difficulty": 3,
    "answer": "error",
    "hint": "<p>The way that <code>f</code> and <code>g</code> are written is not interchangeable.</p>\n",
    "explanation": "<p>Function pointer comparison is generally a Bad Idea. It is easily possible to\nget nonsensical behavior in optimized builds. For a jaw-dropping example of such\nbehavior, check out <a target=\"_blank\" href=\"https://github.com/rust-lang/rust/issues/54685\">rust-lang/rust#54685</a> in which <code>x == y</code> is both true and\nnot true at the same time.</p>\n<p>That said, the quiz code in this question fails to compile. Here is the compiler\noutput:</p>\n<pre><code>error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n --&gt; questions/011.rs:5:18\n  |\n5 |     let pf = f::&lt;'static&gt; as fn();\n  |                  ^^^^^^^\n  |\nnote: the late bound lifetime parameter is introduced here\n</code></pre>\n<p>Generic parameters can be either early bound or late bound. Currently (and for\nthe forseeable future) type parameters are always early bound, but lifetime\nparameters can be either early or late bound.</p>\n<p>Early bound parameters are determined by the compiler during monomorphization.\nSince type parameters are always early bound, you cannot have a value whose\ntype has an unresolved type parameter. For example:</p>\n<pre><code>fn m&lt;T&gt;() {}\n\nfn main() {\n  let m1 = m::&lt;u8&gt;; // ok\n  let m2 = m; // error: cannot infer type for `T`\n}\n</code></pre>\n<p>However, this is often allowed for lifetime parameters:</p>\n<pre><code>fn m&lt;'a&gt;(_: &amp;'a ()) {}\n\nfn main() {\n  let m1 = m; // ok even though 'a isn't provided\n}\n</code></pre>\n<p>Since the actual choice of lifetime <code>'a</code> depends on how it is called, we are\nallowed to omit the lifetime parameter and it will be determined at the call\nsite. The lifetime can even be different for each time it gets called.</p>\n<p>For this reason, we cannot specify the lifetime on this function until it is\ncalled: </p>\n<pre><code>// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\nlet m2 = m::&lt;'static&gt;;\n</code></pre>\n<p>We may not even ask the borrow checker to infer it too soon:</p>\n<pre><code>// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\nlet m3 = m::&lt;'_&gt;;\n</code></pre>\n<p>The idea of late bound parameters overlaps considerably with a feature of Rust\ncalled &quot;higher ranked trait bounds&quot; (HRTB). This is a mechanism for expressing\nthat bounds on a trait's parameters are late bound. Currently this is limited to\nlifetime parameters, but the same idea exists in other languages (such as\nHaskell) for type parameters, which is where the term &quot;higher ranked&quot; comes\nfrom.</p>\n<p>The syntax to express a HRTB for lifetimes uses the <code>for</code> keyword. To express\nthe type of <code>m1</code> above, we could have written:</p>\n<pre><code>let m1: for&lt;'r&gt; fn(&amp;'r ()) = m;\n</code></pre>\n<p>You can think of this as meaning: &quot;There is a lifetime but it we don't need to\nknow what it is just yet&quot;.</p>\n<p>Lifetimes on <em>data types</em> are always early bound, unless the developer has\nexplicitly used the HRTB <code>for</code> syntax. On <em>functions</em>, lifetimes are late bound\nby default, but can be early bound if:</p>\n<ul>\n<li>The lifetime is declared outside the function signature, e.g. in a struct\nmethod it could be from the struct itself.</li>\n<li>The lifetime is not constrained by the function signature. An example of a\nconstraint is that the lifetime is used in the type of an argument or return \ntype. This is because having no constraints implies that the lifetime is\n<em>irrelevant</em> to the function.</li>\n</ul>\n<p>The signature <code>fn f&lt;'a&gt;()</code> has an early bound lifetime parameter because the\nlifetime <code>'a</code> is not used and therefore it doesn't matter what it is. The\nsignature <code>fn g&lt;'a: 'a&gt;()</code> has a late bound lifetime parameter because it is\nconstrained â€” even though the constraint is also pointless. This is perhaps a\nquirk of the current implementation, but there it is.</p>\n"
  },
  "12": {
    "code": "struct D(u8);\n\nimpl Drop for D {\n    fn drop(&mut self) {\n        print!(\"{}\", self.0);\n    }\n}\n\nstruct S {\n    d: D,\n    x: u8,\n}\n\nfn main() {\n    let S { x, .. } = S {\n        d: D(1),\n        x: 2,\n    };\n    print!(\"{}\", x);\n\n    let S { ref x, .. } = S {\n        d: D(3),\n        x: 4,\n    };\n    print!(\"{}\", x);\n}\n",
    "difficulty": 1,
    "answer": "1243",
    "hint": "<p>The pattern <code>S { ref x, .. }</code> borrows a binding <code>x</code> from the owner of a value of\ntype <code>S</code>.</p>\n",
    "explanation": "<p>This question involves drop-placement. Where does <code>D</code> get dropped?</p>\n<p>In the first <code>let</code>-binding, we <a target=\"_blank\" href=\"https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values\">destructure</a> a value of type <code>S</code> into its field\n<code>x</code> of type <code>u8</code> as well as <code>..</code> which represents &quot;the rest of <code>S</code>&quot;. The part\nthat is the rest of <code>S</code> is dropped immediately at that point because it no\nlonger has an owner.</p>\n<p>In the second <code>let</code>-binding, we borrow a field <code>x</code> from the owner of a value of\ntype <code>S</code>. The whole value of type <code>S</code> remains in scope during the time that its\nfield <code>x</code> is borrowed, and goes out of scope at the close curly brace of <code>main</code>.</p>\n<p>The output is <code>1243</code>.</p>\n"
  },
  "13": {
    "code": "struct S;\n\nfn main() {\n    let [x, y] = &mut [S, S];\n    let eq = x as *mut S == y as *mut S;\n    print!(\"{}\", eq as u8);\n}\n",
    "difficulty": 1,
    "answer": "1",
    "hint": "<p>Is it okay for two mutable references to point to the same memory location? What\ncould go wrong?</p>\n",
    "explanation": "<p>In this code, <code>S</code> is a <a target=\"_blank\" href=\"https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\">zero sized type</a> or ZST. Zero sized types are\ncompile-time concepts that disappear during compilation and have a runtime\nrepresentation of zero bytes.</p>\n<p>The first line of <code>main</code> creates a local value of type <code>[S; 2]</code>. Let's refer to\nthat temporary as <code>tmp</code>. The <code>let</code>-binding binds two references into <code>tmp</code>, <code>x</code>\nreferring to <code>&amp;mut tmp[0]</code> and <code>y</code> referring to <code>&amp;mut tmp[1]</code>.</p>\n<p>On the second line of <code>main</code> we want to know whether <code>x</code> and <code>y</code> as pointers\nhave the same value.</p>\n<p>The array type <code>[S; 2]</code> is itself a zero sized type. You can confirm this by\nprinting the value of <code>std::mem::size_of::&lt;[S; 2]&gt;()</code>. Indeed the first and\nsecond element of the array have the same memory address.</p>\n<p>Ordinarily having multiple mutable references to the same memory location would\nnot be safe, but in the case of mutable references to zero sized types,\ndereferencing is a no-op so there is no way to violate any memory safety\nguarantees this way.</p>\n"
  },
  "14": {
    "code": "trait Trait: Sized {\n    fn is_reference(self) -> bool;\n}\n\nimpl<'a, T> Trait for &'a T {\n    fn is_reference(self) -> bool {\n        true\n    }\n}\n\nfn main() {\n    match 0.is_reference() {\n        true => print!(\"1\"),\n        false => print!(\"0\"),\n    }\n\n    match '?'.is_reference() {\n        true => print!(\"1\"),\n        false => {\n            impl Trait for char {\n                fn is_reference(self) -> bool {\n                    false\n                }\n            }\n            print!(\"0\")\n        }\n    }\n}\n",
    "difficulty": 1,
    "answer": "10",
    "hint": "<p>Trait method auto-ref is covered in <a target=\"_blank\" href=\"https://stackoverflow.com/a/28552082/6086311\">this Stack Overflow answer</a>.</p>\n",
    "explanation": "<p>Trait impls anywhere in a program are always in scope, so there is no\nsignificance to the <code>impl Trait for char</code> being written inside of a block of\ncode. In particular, that impl is visible throughout the whole program, not just\nwithin the block containing the impl.</p>\n<p>This question relates to the behavior of trait method auto-ref which is covered\nin <a target=\"_blank\" href=\"https://stackoverflow.com/a/28552082/6086311\">this Stack Overflow answer</a>.</p>\n<p>The call to <code>0.is_reference()</code> observes that there is no implementation of\n<code>Trait</code> for an integer type that we could call directly. Method resolution\ninserts an auto-ref, effectively evaluating <code>(&amp;0).is_reference()</code>. This time the\ncall matches <code>impl&lt;'a, T&gt; Trait for &amp;'a T</code> and prints <code>1</code>.</p>\n<p>The call to <code>'?'.is_reference()</code> instead finds <code>impl Trait for char</code>, printing\n<code>0</code>.</p>\n"
  },
  "15": {
    "code": "trait Trait {\n    fn f(&self);\n}\n\nimpl Trait for u32 {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl<'a> Trait for &'a i32 {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    let x = &0;\n    x.f();\n}\n",
    "difficulty": 1,
    "answer": "1",
    "hint": "<p>What type would type inference infer for <code>x</code>?</p>\n",
    "explanation": "<p>During type inference the variable <code>x</code> has type <code>&amp;{integer}</code>, a reference to\nsome as yet undetermined integer type.</p>\n<p>If we want to resolve the trait method call <code>Trait::f(x)</code>, we find that its\nargument <code>x</code> must be of type <code>&amp;Self</code> for some type <code>Self</code> that implements\n<code>Trait</code>. We find that inferring <code>0: u32</code> satisfies both the constraint that\n<code>u32</code> is an integer as well as <code>u32</code> implements <code>Trait</code>, so the method call ends\nup calling <code>&lt;u32 as Trait&gt;::f(x)</code> and prints <code>1</code>.</p>\n<p>Trait method resolution is covered in more detail in <a target=\"_blank\" href=\"https://stackoverflow.com/a/28552082/6086311\">this Stack Overflow\nanswer</a>.</p>\n"
  },
  "16": {
    "code": "fn main() {\n    let mut x = 4;\n    --x;\n    print!(\"{}{}\", --x, --x);\n}\n",
    "difficulty": 1,
    "answer": "44",
    "hint": "<p>The set of operators supported by Rust is documented in <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/ops/index.html\"><code>std::ops</code></a>.</p>\n",
    "explanation": "<p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The\nRust language design FAQ (no longer available online) used to touch on the\nreason:</p>\n<blockquote>\n<p><strong>Why doesn't Rust have increment and decrement operators?</strong><br>\nPreincrement and postincrement (and the decrement equivalents), while\nconvenient, are also fairly complex. They require knowledge of evaluation\norder, and often lead to subtle bugs and undefined behavior in C and C++. <code>x = x + 1</code> or <code>x += 1</code> is only slightly longer, but unambiguous.</p>\n</blockquote>\n<p>In the absense of a decrement operator, <code>--x</code> is parsed as <code>-(-x)</code>. In the case\nof <code>x = 4</code> this would be <code>-(-4)</code> which is <code>4</code>. The program is equivalent to:</p>\n<pre><code class=\"language-rust\">fn main() {\n    let mut x = 4;\n    4;\n    print!(&quot;{}{}&quot;, 4, 4);\n}\n</code></pre>\n"
  },
  "17": {
    "code": "fn main() {\n    let mut a = 5;\n    let mut b = 3;\n    print!(\"{}\", a-- - --b);\n}\n",
    "difficulty": 1,
    "answer": "2",
    "hint": "<p>The set of operators supported by Rust is documented in <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/ops/index.html\"><code>std::ops</code></a>.</p>\n",
    "explanation": "<p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The\nRust language design FAQ (no longer available online) used to touch on the\nreason:</p>\n<blockquote>\n<p><strong>Why doesn't Rust have increment and decrement operators?</strong><br>\nPreincrement and postincrement (and the decrement equivalents), while\nconvenient, are also fairly complex. They require knowledge of evaluation\norder, and often lead to subtle bugs and undefined behavior in C and C++. <code>x = x + 1</code> or <code>x += 1</code> is only slightly longer, but unambiguous.</p>\n</blockquote>\n<p>In the absense of postfix and prefix decrement operators, <code>a-- - --b</code> is parsed\nas <code>a - (-(-(-(-b))))</code>. In the case of <code>a = 5</code> and <code>b = 3</code> the value of this\nexpression is <code>5 - 3</code> which is <code>2</code>.</p>\n"
  },
  "18": {
    "code": "struct S {\n    f: fn(),\n}\n\nimpl S {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let print2 = || print!(\"2\");\n    S { f: print2 }.f();\n}\n",
    "difficulty": 1,
    "answer": "1",
    "hint": "<p>The call <code>.f()</code> resolves to either the field <code>f</code> or the inherent method <code>f</code>. How\nwould you write a call to the other one?</p>\n",
    "explanation": "<p>A call that looks like <code>.f()</code> always resolves to a method, in this case the\ninherent method <code>S::f</code>. If there were no method <code>f</code> in scope, a call like this\nwould fail to compile even if a field <code>f</code> exists and contains a function\npointer.</p>\n<p>To call the function pointer stored in field <code>f</code>, we would need to write\nparentheses around the field access:</p>\n<pre><code class=\"language-rust\">fn main() {\n    let print2 = || print!(&quot;2&quot;);\n    (S { f: print2 }.f)();\n}\n</code></pre>\n"
  },
  "19": {
    "code": "struct S;\n\nimpl Drop for S {\n    fn drop(&mut self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let s = S;\n    let _ = s;\n    print!(\"2\");\n}\n",
    "difficulty": 1,
    "answer": "21",
    "hint": "<p>Does <code>s</code> get moved?</p>\n",
    "explanation": "<p>The relevant line is <code>let _ = s</code>. If this line does not move <code>s</code> then <code>s</code> will\ncontinue to live until the close curly brace and the program would print <code>21</code>.\nBut if this line does move <code>s</code>, without binding it, then the moved value of type\n<code>S</code> would be dropped immediately and the program would print <code>12</code>.</p>\n<p>In fact <code>s</code> does not get moved and the output is <code>21</code>.</p>\n"
  },
  "20": {
    "code": "fn return1() {\n    if (return { print!(\"1\") }) {\n    }\n}\n\nfn return2() {\n    if return { print!(\"2\") } {\n    }\n}\n\nfn break1() {\n    loop {\n        if (break { print!(\"1\") }) {\n        }\n    }\n}\n\nfn break2() {\n    loop {\n        if break { print!(\"2\") } {\n        }\n    }\n}\n\nfn main() {\n    return1();\n    return2();\n    break1();\n    break2();\n}\n",
    "difficulty": 2,
    "answer": "121",
    "hint": "<p>The Rust grammar involving <code>break</code> is different from the grammar involving\n<code>return</code>.</p>\n",
    "explanation": "<p>Let's work through the functions one at a time.</p>\n<ul>\n<li>\n<p><code>fn return1</code></p>\n<p>The condition of the <code>if</code>-statement is parsed as a return-expression that\nreturns the value <code>{ print!(&quot;1&quot;) }</code> of type <code>()</code>. The value needs to be\nevaluated prior to being returned so this function prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>fn return2</code></p>\n<p>This function is parsed the same as <code>return1</code>. The <code>return</code> keyword eagerly\nconsumes a trailing return value, even if the return value begins with a\ncurly brace, and even in the condition of an <code>if</code>-statement where curly\nbraces such as in a struct literal would ordinarly not be accepted. This\nfunction prints <code>2</code>.</p>\n</li>\n<li>\n<p><code>fn break1</code></p>\n<p>The condition of the <code>if</code>-statement is a break-with-value expression that\nbreaks out of the enclosing loop with the value <code>{ print!(&quot;1&quot;) }</code> of type\n<code>()</code>. Similar to <code>return1</code>, in order to break with this value the value\nneeds to be evaluated and this function prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>fn break2</code></p>\n<p>Here we observe a difference between the grammar of <code>break</code> and the grammar\nof <code>return</code>. Unlike <code>return</code>, the <code>break</code> keyword in the condition of this\n<code>if</code>-statement <em>does not</em> eagerly parse a value that begins with a curly\nbrace. This code is parsed as:</p>\n<pre><code class=\"language-rust\">loop {\n    if break {\n        print!(&quot;2&quot;)\n    }\n    {}\n}\n</code></pre>\n<p>We break out of the loop before executing the print, so this function does\nnot print anything.</p>\n<p>I believe the reason for the difference between <code>return</code> and <code>break</code> is that\nreturning a value was obviously supported at Rust 1.0 and well before, but\nbreak-with-value was introduced fairly late, in <a target=\"_blank\" href=\"https://blog.rust-lang.org/2017/07/20/Rust-1.19.html\">Rust 1.19</a>. The code in\n<code>break2</code> was perfectly legal Rust code prior to Rust 1.19 so we cannot\nchange its behavior when implementing the break-with-value language feature.</p>\n<p>It is possible that a future Edition would adjust the two grammars to align\nwith each other.</p>\n</li>\n</ul>\n<p>The output from <code>main</code> is <code>121</code>.</p>\n"
  },
  "21": {
    "code": "trait Trait {\n    fn f(&self);\n}\n\nimpl<F: FnOnce() -> bool> Trait for F {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for () {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    let x = || { (return) || true; };\n    x().f();\n\n    let x = loop { (break) || true; };\n    x.f();\n\n    let x = || { return (|| true); };\n    x().f();\n\n    let x = loop { break (|| true); };\n    x.f();\n\n    let x = || { return || true; };\n    x().f();\n\n    let x = loop { break || true; };\n    x.f();\n}\n",
    "difficulty": 2,
    "answer": "221111",
    "hint": "<p>The <code>break</code> and <code>return</code> keywords have the same grammar in this question.</p>\n",
    "explanation": "<p>We want to know whether each possible parenthesization of <code>return || true;</code> and\n<code>break || true;</code> evaluates to the closure <code>|| true</code> or to the unit value <code>()</code>.</p>\n<ul>\n<li>\n<p><code>let x = || { (return) || true; };</code></p>\n<p>On this line, <code>x</code> is a closure that returns <code>()</code>. It is equivalent to <code>let x = || {}</code>. When we call <code>x().f()</code>, the method <code>f</code> resolves to <code>impl Trait for ()</code> which prints <code>2</code>.</p>\n<p>The type of the <em>expression</em> <code>(return)</code> is the primitive <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/primitive.never.html\">never</a> type,\nusually written as <code>!</code>. It is legal to compute <code>! || true</code> because <code>!</code> can\nfill in for any type, in this case bool. The expression <code>! || true</code> is a\nlogical-OR with bool on both the left-hand side and right-hand side.</p>\n<p>The behavior of <code>!</code> of filling in for any type is what allows us to write:</p>\n<pre><code class=\"language-rust\">fn f() -&gt; bool {\n    unimplemented!()\n}\n</code></pre>\n<p>in which the type of <code>unimplemented!()</code>, since it panics without evaluating\nto any value, is also <code>!</code>.</p>\n</li>\n<li>\n<p><code>let x = loop { (break) || true; };</code></p>\n<p>Similar to <code>(return)</code>, the type of <code>(break)</code> is the never type <code>!</code>. This\ncode breaks out of the loop with the implicit value <code>()</code>, so <code>x</code> is of type\n<code>()</code>. Calling <code>x.f()</code> will print <code>2</code>.</p>\n</li>\n<li>\n<p><code>let x = || { return (|| true); };</code></p>\n<p>On this line <code>x</code> is a closure that returns a closure that returns <code>true</code>.\nYou could write <code>x()()</code> and that would be <code>true</code>.</p>\n<p>The quiz code calls <code>x().f()</code> which resolves to <code>impl&lt;F&gt; Trait for F where F: FnOnce() -&gt; bool</code>. That trait impl prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>let x = loop { break (|| true); };</code></p>\n<p>This is a loop containing a break-with-value expression. The argument of the\n<code>break</code> becomes the value of the enclosing <code>loop</code>. This code is equivalent\nto <code>let x = || true</code>.</p>\n<p>When we call <code>x.f()</code> it uses the <code>FnOnce</code> impl of <code>Trait</code> which prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>let x = || { return || true; };</code></p>\n<p>Now we arrive at the meat of this quiz question. Is <code>return || true</code> parsed\nthe same as <code>(return) || true</code> or as <code>return (|| true)</code>?</p>\n<p>It turns out to be the latter, so <code>x</code> is a closure that returns a closure\nthat returns true. <code>x().f()</code> prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>let x = loop { break || true; };</code></p>\n<p>Similar question here, is this <code>(break) || true</code> or <code>break (|| true)</code>?</p>\n<p>The break-with-value language feature was added to Rust more than two years\nafter 1.0, in <a target=\"_blank\" href=\"https://blog.rust-lang.org/2017/07/20/Rust-1.19.html\">Rust 1.19</a>. Prior to break-with-value, <code>break || true</code> was\nperfectly legal Rust code that parsed as <code>(break) || true</code>.</p>\n<p>In Rust 1.19 the behavior of this code was unintentionally broken by the\nlanguage such that now it parses as <code>break (|| true)</code> and the printed value\nis <code>1</code>.</p>\n<p>If we had noticed this change in meaning during the development of Rust\n1.19, we may have adjusted the parsing to preserve the meaning of existing\ncode. Unfortunately doing so would result in a grammar that behaves\ndifferently between <code>return</code> and <code>break</code> for no justifiable reason other\nthan an accident of history.</p>\n<p>Or it is possible we would have ruled this an edge case of syntax that would\nnever appear in real code, used <a target=\"_blank\" href=\"https://github.com/rust-lang-nursery/crater\">Crater</a> to validate that hypothesis, and\nbroken the behavior intentionally.</p>\n</li>\n</ul>\n<p>The total output from <code>main</code> is <code>221111</code>.</p>\n"
  },
  "22": {
    "code": "macro_rules! m {\n    ($a:tt) => { print!(\"1\") };\n    ($a:tt $b:tt) => { print!(\"2\") };\n    ($a:tt $b:tt $c:tt) => { print!(\"3\") };\n    ($a:tt $b:tt $c:tt $d:tt) => { print!(\"4\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt) => { print!(\"5\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) => { print!(\"6\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) => { print!(\"7\") };\n}\n\nfn main() {\n    m!(-1);\n    m!(-1.);\n    m!(-1.0);\n    m!(-1.0e1);\n    m!(-1.0e-1);\n}\n",
    "difficulty": 1,
    "answer": "22222",
    "hint": "<p>The macro is counting how many &quot;tokens&quot; are in its input.</p>\n",
    "explanation": "<p>All five invocations of <code>m!</code> pass two tokens as input: a minus sign followed by\nan integer or floating point literal token.</p>\n<p>The floating point literals <code>1.</code>, <code>1.0</code>, <code>1.0e1</code>, <code>1.0e-1</code> are each a single\natomic token.</p>\n<p>The parser built into the Rust compiler always parses a negative sign as a\nseparate token from the numeric literal that is being negating. However, it is\npossible for a user-defined parser within a <a target=\"_blank\" href=\"https://github.com/dtolnay/syn\">procedural macro</a> to construct a\nnegative number as a single token by passing a negative integer or negative\nfloating point value to one of the constructors of <a target=\"_blank\" href=\"https://doc.rust-lang.org/proc_macro/struct.Literal.html\"><code>proc_macro::Literal</code></a>. If\nsuch a negative literal ends up in the input of a subsequent procedural macro\ninvocation, it is up to the compiler whether to rewrite into a pair of tokens or\nkeep them as one.</p>\n<p>The behavior of the compiler's parser is observable in the surface language as\nwell, not only in macros. For example the following code prints <code>-81</code> because\nthe expression is parsed as <code>-(3i32.pow(4))</code> rather than <code>(-3i32).pow(4)</code>.</p>\n<pre><code class=\"language-rust\">fn main() {\n    let n = -3i32.pow(4);\n    println!(&quot;{}&quot;, n);\n}\n</code></pre>\n"
  },
  "23": {
    "code": "trait Trait {\n    fn f(&self);\n    fn g(&self);\n}\n\nstruct S;\n\nimpl S {\n    fn f(&self) {\n        print!(\"1\");\n    }\n\n    fn g(&mut self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for S {\n    fn f(&self) {\n        print!(\"2\");\n    }\n\n    fn g(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    S.f();\n    S.g();\n}\n",
    "difficulty": 2,
    "answer": "12",
    "hint": "<p>I can't help you with this one. This is a pretty arbitrary choice made by the\nlanguage. Try all the possibilities!</p>\n",
    "explanation": "<p><code>S.f()</code> calls the inherent method <code>f</code>. If an inherent method and a trait method\nhave the same name and receiver type, plain method call syntax will always\nprefer the inherent method. The caller would need to write <code>Trait::f(&amp;S)</code> or <code>&lt;S as Trait&gt;::f(&amp;S)</code> in order to call the trait method.</p>\n<p>It is important for macro authors to be aware of this. Macro-generated code\ntypically should not use method call syntax to invoke trait methods on types\ndefined by the user. Those calls could get unintentially hijacked by inherent\nmethods having the same name as the trait method.</p>\n<p>On the other hand, <code>S.g()</code> calls the trait method <code>g</code>. Auto-ref during method\nresolution always prefers making something into <code>&amp;</code> over making it into <code>&amp;mut</code>\nwhere either one would work.</p>\n<p>See <a target=\"_blank\" href=\"https://stackoverflow.com/a/28552082/6086311\">this Stack Overflow answer</a> for a more detailed explanation of auto-ref\nduring method resolution.</p>\n"
  },
  "24": {
    "code": "fn main() {\n    let x: u8 = 1;\n    const K: u8 = 2;\n\n    macro_rules! m {\n        () => {\n            print!(\"{}{}\", x, K);\n        };\n    }\n\n    {\n        let x: u8 = 3;\n        const K: u8 = 4;\n\n        m!();\n    }\n}\n",
    "difficulty": 1,
    "answer": "14",
    "hint": "<p>Hygiene in <code>macro_rules!</code> only applies to local variables.</p>\n",
    "explanation": "<p>This program prints <code>14</code> because hygiene in <code>macro_rules!</code> only applies to local\nvariables.</p>\n<p>You can imagine hygiene as a way of assigning a color to each mention of the\nname of a local variable, allowing for there to be multiple distinguishable\nlocal variables in scope simultaneously with the same name.</p>\n<p>At the top of <code>main</code>, suppose we consider the name of the local variable <code>x</code> to\nbe a purple <code>x</code>. The name of the constant <code>K</code> is just plain <code>K</code>, as constants\nare considered items rather than local variables (you can place items outside of\na function body; you cannot place local variables outside of a function body).</p>\n<pre><code>let <b style=\"background-color:mediumpurple;color:white\">x</b>: u8 = 1;\nconst <b>K</b>: u8 = 2;</code></pre>\n<p>Continuing down the body of <code>main</code>, within the declaration of the macro <code>m!</code>\nthere are identifiers <code>x</code> and <code>K</code> being used. Since there is a local variable\n<code>x</code> in scope, the use of the identifier <code>x</code> within the macro body picks up the\nsame color as the local variable <code>x</code>. There is no local variable <code>K</code> in scope so\nthe <code>K</code> within the declaration of the macro is assigned some new color, say\norange.</p>\n<pre><code>macro_rules! m {\n    () => {\n        print!(\"{}{}\", <b style=\"background-color:mediumpurple;color:white\">x</b>, <b style=\"background-color:coral;color:white\">K</b>);\n    };\n}</code></pre>\n<p>Next we enter a new scope (delimited by curly braces) containing another <code>x</code> and\n<code>K</code>. Every new local variable always introduces a new color so let's call this\n<code>x</code> blue. The const again is not a local variable so no color is assigned to\n<code>K</code>.</p>\n<pre><code>{\n    let <b style=\"background-color:dodgerblue;color:white\">x</b>: u8 = 3;\n    const <b>K</b>: u8 = 4;\n\n    m!();\n}</code></pre>\n<p>When <code>m!()</code> expands, the expanded code refers to a purple <code>x</code> and an orange <code>K</code>.\nThe purple <code>x</code> is distinguishable from the blue <code>x</code> -- the value of the purple\n<code>x</code> is printed which is <code>1</code>. As for the <code>K</code>, an unhygienic (uncolored) <code>K</code> is\nallowed to act like any color. The second <code>K</code> is shadowing the first one. It\ngets picked up when looking for an orange <code>K</code> and its value is printed, which is\n<code>4</code>.</p>\n<p>So the output of the quiz code is <code>14</code>.</p>\n"
  },
  "25": {
    "code": "use std::fmt::{self, Display};\n\nstruct S;\n\nimpl Display for S {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"1\")\n    }\n}\n\nimpl Drop for S {\n    fn drop(&mut self) {\n        print!(\"2\");\n    }\n}\n\nfn f() -> S {\n    S\n}\n\nfn main() {\n    let S = f();\n    print!(\"{}\", S);\n}\n",
    "difficulty": 1,
    "answer": "212",
    "hint": "<p>Figure out what values are owned by which variables where. A value is dropped\nwhen it no longer has an owner.</p>\n",
    "explanation": "<p>This program prints <code>212</code>.</p>\n<p>No value of type <code>S</code> gets dropped within the body of function <code>f</code>. The function\n<code>f</code> conjures an <code>S</code> and returns ownership of it to the caller of <code>f</code>; the caller\ndetermines when to drop the <code>S</code> of which it received ownership.</p>\n<p>On the first line of <code>main</code>, we call <code>f()</code> and perform an infallible match that\nbinds no new variables. As no variables are declared on this line, there is no\nvariable that could be the owner of the <code>S</code> returned by <code>f()</code> so that <code>S</code> is\ndropped at that point, printing <code>2</code>. The <code>S</code> in <code>let S = f()</code> is a unit struct\npattern (not a variable name) that matches a value of type <code>S</code> via\n<a target=\"_blank\" href=\"https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values\">destructuring</a> but does not bind the value to any variable.</p>\n<p>The second line of <code>main</code> conjures a new <code>S</code>, prints it, and drops it at the\nsemicolon.</p>\n"
  },
  "26": {
    "code": "fn main() {\n    let input = vec![1, 2, 3];\n\n    let parity = input\n        .iter()\n        .map(|x| {\n            print!(\"{}\", x);\n            x % 2\n        });\n\n    for p in parity {\n        print!(\"{}\", p);\n    }\n}\n",
    "difficulty": 1,
    "answer": "112031",
    "hint": "<p>Refer to the documentation of the <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\"><code>Iterator</code></a> trait.</p>\n",
    "explanation": "<p>As described in the documentation of the <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map\"><code>Iterator::map</code></a> method, the map\noperation is performed lazily. The closure provided as an argument to <code>map</code> is\nonly invoked as values are consumed from the resulting iterator. The closure is\nnot applied eagerly to the entire input stream up front.</p>\n<p>In this code, the <code>for</code> loop is what drives the iteration. For each element\nconsumed from the <code>parity</code> iterator, our closure needs to be evaluated one time.\nThus the output will alternate between numbers printed by the closure and\nnumbers printed by the loop body.</p>\n"
  },
  "27": {
    "code": "trait Base {\n    fn method(&self) {\n        print!(\"1\");\n    }\n}\n\ntrait Derived: Base {\n    fn method(&self) {\n        print!(\"2\");\n    }\n}\n\nstruct BothTraits;\nimpl Base for BothTraits {}\nimpl Derived for BothTraits {}\n\nfn dynamic_dispatch(x: &dyn Base) {\n    x.method();\n}\n\nfn static_dispatch<T: Base>(x: T) {\n    x.method();\n}\n\nfn main() {\n    dynamic_dispatch(&BothTraits);\n    static_dispatch(BothTraits);\n}\n",
    "difficulty": 1,
    "answer": "11",
    "hint": "<p><code>Base::method</code> and <code>Derived::method</code> happen to have the same name but are\notherwise unrelated methods. One does not override the other.</p>\n",
    "explanation": "<p>The two traits <code>Base</code> and <code>Derived</code> each define a trait method called <code>method</code>.\nThese methods happen to have the same name but are otherwise unrelated methods\nas explained below.</p>\n<p>Both traits provide a default implementation of their trait method. Default\nimplementations are conceptually copied into each trait impl that does not\nexplicitly define the same method. In this case for example <code>impl Base for BothTraits</code> does not provide its own implementation of <code>Base::method</code>, which\nmeans the implementation of <code>Base</code> for <code>BothTraits</code> will use the default\nbehavior defined by the trait i.e. <code>print!(&quot;1&quot;)</code>.</p>\n<p>Additionally, <code>Derived</code> has <code>Base</code> as a <em>supertrait</em> which means that every type\nthat implements <code>Derived</code> is also required to implement <code>Base</code>. The two trait\nmethods are unrelated despite having the same name -- thus any type that\nimplements <code>Derived</code> will have an implementation of <code>Derived::method</code> as well as\nan implementation of <code>Base::method</code> and the two are free to have different\nbehavior. Supertraits are not inheritance! Supertraits are a constraint that if\nsome trait is implemented, some other trait must also be implemented.</p>\n<p>Let's consider what happens in each of the two methods called from <code>main</code>.</p>\n<ul>\n<li>\n<p><code>dynamic_dispatch(&amp;BothTraits)</code></p>\n<p>The argument <code>x</code> is a reference to the trait object type <code>dyn Base</code>. A\n<em>trait object</em> is a little shim generated by the compiler that implements\nthe trait with the same name by forwarding all trait method calls to trait\nmethods of whatever type the trait object was created from. The forwarding\nis done by reading from a table of function pointers contained within the\ntrait object.</p>\n<pre><code class=\"language-rust\">// Generated by the compiler.\n//\n// This is an implementation of the trait `Base` for the\n// trait object type `dyn Base`, which you can think of as\n// a struct containing function pointers.\nimpl Base for (dyn Base) {\n    fn method(&amp;self) {\n        /*\n        Some automatically generated implementation detail\n        that ends up calling the right type's impl of the\n        trait method Base::method.\n        */\n    }\n}\n</code></pre>\n<p>In the quiz code, <code>x.method()</code> is a call to this automatically generated\nmethod whose fully qualified name is <code>&lt;dyn Base as Base&gt;::method</code>. Since <code>x</code>\nwas obtained by converting a <code>BothTraits</code> to <code>dyn Base</code>, the automatically\ngenerated implementation detail will wind up forwarding to <code>&lt;BothTraits as Base&gt;::method</code> which prints <code>1</code>.</p>\n<p>Hopefully it's clear from all of this that nothing here has anything to do\nwith the unrelated trait method <code>Derived::method</code> defined by <code>BothTraits</code>.\nEspecially notice that <code>x.method()</code> cannot be a call to <code>Derived::method</code>\nbecause <code>x</code> is of type <code>dyn Base</code> and there is no implementation of\n<code>Derived</code> for <code>dyn Base</code>.</p>\n</li>\n<li>\n<p><code>static_dispatch(BothTraits)</code></p>\n<p>At compile time we know that <code>x.method()</code> is a call to <code>&lt;T as Base&gt;::method</code>. Type inference within generic functions in Rust happens\nindependently of any concrete instantiation of the generic function i.e.\nbefore we know what <code>T</code> may be, other than the fact that it implements\n<code>Base</code>. Thus no inherent method on the concrete type <code>T</code> or any other trait\nmethod may affect what method <code>x.method()</code> is calling. By the time that <code>T</code>\nis decided, it has already been determined that <code>x.method()</code> is calling <code>&lt;T as Base&gt;::method</code>.</p>\n<p>The generic function is instantiated with <code>T</code> equal to <code>BothTraits</code> so this\nis going to call <code>&lt;BothTraits as Base&gt;::method</code> which prints <code>1</code>.</p>\n</li>\n</ul>\n<p>If you are familiar with C++, the behavior of this code in Rust is <em>different</em>\nfrom the behavior of superficially analogous C++ code. In C++ the output would\nbe <code>22</code> as seen in the following implementation. This highlights the difference\nbetween Rust's traits and supertraits vs C++'s inheritance.</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nstruct Base {\n    virtual void method() const {\n        std::cout &lt;&lt; &quot;1&quot;;\n    }\n};\n\nstruct Derived: Base {\n    void method() const {\n        std::cout &lt;&lt; &quot;2&quot;;\n    }\n};\n\nvoid dynamic_dispatch(const Base &amp;x) {\n    x.method();\n}\n\ntemplate &lt;typename T&gt;\nvoid static_dispatch(const T x) {\n    x.method();\n}\n\nint main() {\n    dynamic_dispatch(Derived{});\n    static_dispatch(Derived{});\n}\n</code></pre>\n"
  },
  "28": {
    "code": "struct Guard;\n\nimpl Drop for Guard {\n    fn drop(&mut self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let _guard = Guard;\n    print!(\"3\");\n    let _ = Guard;\n    print!(\"2\");\n}\n",
    "difficulty": 1,
    "answer": "3121",
    "hint": "<p>A value is dropped when it no longer has an owner.</p>\n",
    "explanation": "<p>The program prints <code>3121</code>. That is, the <code>Drop</code> impl for <code>let _guard = Guard</code>\nruns at the end of main but the <code>Drop</code> impl for <code>let _ = Guard</code> runs right away.</p>\n<p>In general, a value is dropped when it no longer has an owner. The variable\n<code>_guard</code> owns the first value of type <code>Guard</code> and remains in scope until the end\nof main. The <code>_</code> is not a variable but a wildcard pattern that binds nothing;\nsince no variables are bound on this line, there is no variable to be the owner\nof the second value of type <code>Guard</code> and that value is dropped on the same line.</p>\n<p>This distinction between the underscore pattern vs variables with a leading\nunderscore is incredibly important to remember when working with lock guards in\nunsafe code.</p>\n<pre><code>use lazy_static::lazy_static;\nuse std::sync::Mutex;\n\nlazy_static! {\n    static ref MUTEX: Mutex&lt;()&gt; = Mutex::new(());\n}\n\n/// MUTEX must be held when accessing this value.\nstatic mut VALUE: usize = 0;\n\nfn main() {\n    let _guard = MUTEX.lock().unwrap();\n    unsafe {\n        VALUE += 1;\n    }\n}\n</code></pre>\n<p>If this code were to use <code>let _ = MUTEX.lock().unwrap()</code> then the mutex guard\nwould be dropped immediately, releasing the mutex and failing to guard the\naccess of <code>VALUE</code>.</p>\n"
  },
  "29": {
    "code": "trait Trait {\n    fn p(&self);\n}\n\nimpl Trait for (u32) {\n    fn p(&self) { print!(\"1\"); }\n}\n\nimpl Trait for (i32,) {\n    fn p(&self) { print!(\"2\"); }\n}\n\nimpl Trait for (u32, u32) {\n    fn p(&self) { print!(\"3\"); }\n}\n\nimpl Trait for (i32, i32,) {\n    fn p(&self) { print!(\"4\"); }\n}\n\nfn main() {\n    (0).p();\n    (0,).p();\n    (0, 0).p();\n    (0, 0,).p();\n}\n",
    "difficulty": 1,
    "answer": "1244",
    "hint": "<p>A value in parentheses does not have the same type as a 1-tuple.</p>\n",
    "explanation": "<p>The trailing comma is required in the case of a 1-tuple, <code>(0,)</code>, because it\ndisambiguates it from <code>(0)</code> which is identical to <code>0</code>. However, for larger\ntuples, it is entirely optional: <code>(i32)</code> is a distinct type from <code>(i32,)</code>, but\n<code>(i32, i32)</code> and <code>(i32, i32,)</code> are the same.</p>\n<p>An integral literal <code>0</code> can be inferred to be any integer type, but defaults to\n<code>i32</code> if insufficient type information is available. <code>(0)</code> is inferred to be a\n<code>u32</code> and <code>(0,)</code> is inferred to be a <code>(i32,)</code> because those are respectively the\nonly integral and 1-tuple types with an implementation for <code>Trait</code>.</p>\n<p>Since <code>(0, 0)</code> and <code>(0, 0,)</code> have the same type, the output of their <code>p</code> methods\nmust be the same, but Rust needs to somehow choose between the two possible\nimplementations of <code>Trait</code>, namely <code>(u32, u32)</code> and <code>(i32, i32)</code>. Since <code>i32</code> is\nthe default integral type, <code>(i32, i32)</code> is chosen in both cases.</p>\n"
  }
};
