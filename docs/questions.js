var questions = {
  "1": {
    "code": "macro_rules! m {\n    ($($s:stmt)*) => {\n        $(\n            { stringify!($s); 1 }\n        )<<*\n    };\n}\n\nfn main() {\n    print!(\n        \"{}{}{}\",\n        m! { return || true },\n        m! { (return) || true },\n        m! { {return} || true },\n    );\n}\n",
    "difficulty": 3,
    "answer": "112",
    "hint": "<p>The expression in the output of the macro evaluates to the same value as <code>1 &lt;&lt; (n - 1)</code> where <code>n</code> is the number of statements contained in the macro input.</p>\n",
    "explanation": "<p>This question revolves around where the Rust grammar places statement\nboundaries.</p>\n<p>The input rule of the macro <code>m!</code> is <code>$($s:stmt)*</code> which matches zero or more\nRust statements. The <code>$(</code>...<code>)*</code> part of the rule is a <em>repetition</em> which\nmatches the contents of the repetition zero or more times, and the <code>$s:stmt</code> is\na fragment specifier that matches a Rust statement (<code>stmt</code>) conforming to the\nrules of the Rust grammar. The matched statements are available within the\nexpanded code as the fragment variable <code>$s</code>.</p>\n<p>A <em>statement</em> is the top-level unit of syntax permitted within a function body.\nAll of the following are examples of statements. The grammar of function bodies\nrequires that some types of statements are followed by a semicolon, but the\nsemicolon is not part of the statement for the purpose of macro syntax.</p>\n<pre><code class=\"language-rust\">// Items are statements.\nstruct S { x: u64 }\n\n// Let-bindings are statements.\nlet mut s = S { x: 1 }\n\n// Expressions are statements.\ns.x + 1\n</code></pre>\n<p>The macro <code>m!</code> expands to zero or more copies of <code>{ stringify!($s); 1 }</code>\nseparated by the <code>&lt;&lt;</code> token. The <code>$(</code>...<code>)&lt;&lt;*</code> part of the rule is a repetition\nusing <code>&lt;&lt;</code> as the separator.</p>\n<p>Using <code>&lt;&lt;</code> as a separator in a repetition in a macro is highly unusual. The most\ncommmonly used separator is the comma, written as <code>$(</code>...<code>),*</code>, but any other\nsingle token is allowed here. Crucially, <code>macro_rules!</code> treats all built-in Rust\noperators as single tokens, even those that consist of multiple characters like\n<code>&lt;&lt;</code>.</p>\n<p>The <code>{ stringify!($s); 1 }</code> is an expression whose value is always 1. The value\nof <code>stringify!($s)</code> is discarded, so this is equivalent to the expression <code>{ 1 }</code>. The reason for having <code>stringify!($s)</code> in there is to control the number of\ntimes the repetition is repeated, which is determined by which fragment\nvariables are used within the repetition. Writing a repetition without using any\nfragment variables inside of it would not be legal.</p>\n<p>Suppose we call this macro with three of the statements shown above as input.</p>\n<pre><code class=\"language-rust\">m! {\n    struct S { x: u64 }\n    let mut s = S { x: 1 }\n    s.x + 1\n}\n</code></pre>\n<p>The macro expands to:</p>\n<pre><code class=\"language-rust\">{ stringify!(struct S { x: u64 }); 1 }\n    &lt;&lt; { stringify!(let mut s = S { x: 1 }); 1 }\n    &lt;&lt; { stringify!(s.x + 1); 1 }\n</code></pre>\n<p>Each of the <code>stringify</code>s expands to a string literal:</p>\n<pre><code class=\"language-rust\">{ \"struct S { x: u64 }\"; 1 }\n    &lt;&lt; { \"let mut s = S { x: 1 }\"; 1 }\n    &lt;&lt; { \"s.x + 1\"; 1 }\n</code></pre>\n<p>The values of the string literals are not used. In this case the expression is\nequivalent to <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>, which is equivalent to <code>1 &lt;&lt; 1 &lt;&lt; 1</code>.\nThe <code>&lt;&lt;</code> operator is left-associative; the numeric value of this expression is\n4.</p>\n<p>Altogether, the relevant behavior of this macro is that it evaluates to <code>1 &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; ...</code> where the number of ones is equal to the number of Rust statements\nin the input of the macro. In closed form, the numeric value is <code>1 &lt;&lt; (n - 1)</code>\nwhere <code>n</code> is the number of statements, except in the case that <code>n</code> is zero where\nthe macro expands to nothing and we get a syntax error at the call site.</p>\n<p>It remains to determine how many statements are in the three invocations of\n<code>m!</code> in the quiz code.</p>\n<ol>\n<li>\n<p><code>return || true</code></p>\n<p>This is a return-expression that would return the closure <code>|| true</code>. It is\nequivalent to <code>return (|| true)</code>. It is parsed as a single statement so the\n<code>m!</code> invocation evaluates to <code>1</code>.</p>\n</li>\n<li>\n<p><code>(return) || true</code></p>\n<p>This is a logical-OR expression. The <code>||</code> is a binary operator, where the\nleft-hand side is the expression <code>(return)</code> (of diverging type <code>!</code>) and the\nright-hand side is the expression <code>true</code>. This expression is a single\nstatement so <code>m!</code> again evaluates to <code>1</code>.</p>\n</li>\n<li>\n<p><code>{return} || true</code></p>\n<p>This one is two statements! A block-statement <code>{return}</code> followed by a\nclosure expression <code>|| true</code>.</p>\n<p>The Rust grammar distinguishes between expressions that require a semicolon\nin order to stand alone as a statement, and expressions that can be\nstatements even without a semicolon. Consider two examples:</p>\n<pre><code class=\"language-rust\">// No trailing semicolon required.\nfor t in vec {\n    /* ... */\n}\n\n// Trailing semicolon required.\nself.skip_whitespace()?;\n</code></pre>\n<p>The list of expression types that stand alone without a semicolon is defined\n<a target=\"_blank\" href=\"https://github.com/rust-lang/rust/blob/1.30.1/src/libsyntax/parse/classify.rs#L17-L37\">here</a> in libsyntax. The distinction informs a few different early\nbail-out cases where the parser decides to finish parsing the current\nexpression.</p>\n<p>Relevant to our case is that block expressions <code>{ /* ... */ }</code> terminate an\nexpression if doing so would be syntactically sensible. The parser does not\neagerly consume binary operators after a block expression. Thus one might\nwrite:</p>\n<pre><code class=\"language-rust\">fn f() -&gt; &amp;'static &amp;'static bool {\n    // Block expression.\n    {\n        println!(\"What a silly function.\");\n    }\n\n    // Reference to reference to true.\n    &amp;&amp;true\n}\n</code></pre>\n<p>In order to parse a block followed by a binary operator, we would need to\nmake it syntactically insensible for the parser to terminate an expression\nat the close curly brace. This would usually be done by wrapping in\nparentheses.</p>\n<pre><code class=\"language-rust\">fn f() -&gt; bool {\n    ({ true } &amp;&amp; true)\n}\n</code></pre>\n</li>\n</ol>\n<p>Anyhow, the output of the program is <code>112</code>.</p>\n"
  },
  "2": {
    "code": "struct S(i32);\n\nimpl std::ops::BitAnd<S> for () {\n    type Output = ();\n\n    fn bitand(self, rhs: S) {\n        print!(\"{}\", rhs.0);\n    }\n}\n\nfn main() {\n    let f = || ( () & S(1) );\n    let g = || { () & S(2) };\n    let h = || ( {} & S(3) );\n    let i = || { {} & S(4) };\n    f();\n    g();\n    h();\n    i();\n}\n",
    "difficulty": 2,
    "answer": "123",
    "hint": "<p>One of these four closures is unlike the other three.</p>\n",
    "explanation": "<p>The closures <code>f</code>, <code>g</code>, and <code>h</code> are all of type <code>impl Fn()</code>. The closure bodies\nare parsed as an invocation of the user-defined bitwise-AND operator defined\nabove by the <code>BitAnd</code> trait impl. When the closures are invoked, the bitwise-AND\nimplementation prints the content of the <code>S</code> from the right-hand side and\nevaluates to <code>()</code>.</p>\n<p>The closure <code>i</code> is different. Formatting the code with rustfmt makes it clearer\nhow <code>i</code> is parsed.</p>\n<pre><code class=\"language-rust\">let i = || {\n    {}\n    &amp;S(4)\n};\n</code></pre>\n<p>The closure body consists of an empty block-statement <code>{}</code> followed by a\n<em>reference</em> to <code>S(4)</code>, not a bitwise-AND. The type of <code>i</code> is <code>impl Fn() -&gt; &amp;'static S</code>.</p>\n<p>The parsing of this case is governed by <a target=\"_blank\" href=\"https://github.com/rust-lang/rust/blob/1.30.1/src/libsyntax/parse/classify.rs#L17-L37\">this code</a> in libsyntax.</p>\n"
  },
  "3": {
    "code": "struct S {\n    x: i32,\n}\n\nconst S: S = S { x: 2 };\n\nfn main() {\n    let v = &mut S;\n    v.x += 1;\n    S.x += 1;\n    print!(\"{}{}\", v.x, S.x);\n}\n",
    "difficulty": 1,
    "answer": "32",
    "hint": "<p>In what ways is a <code>const</code> different from a non-mut <code>static</code>?</p>\n",
    "explanation": "<p>The semantics of <code>const</code> is that any mention of the <code>const</code> by name in\nexpression position is substituted with the value of the <code>const</code> initializer. In\nthis quiz code the behavior is equivalent to:</p>\n<pre><code class=\"language-rust\">struct S {\n    x: i32,\n}\n\nfn main() {\n    let v = &amp;mut S { x: 2 };\n    v.x += 1;\n    S { x: 2 }.x += 1;\n    print!(\"{}{}\", v.x, S { x: 2 }.x);\n}\n</code></pre>\n<p>I have simply substituted every mention of <code>S</code> in expresson position with the\nvalue of <code>const S</code> which is <code>S { x: 2 }</code>.</p>\n<p>The first line of <code>main</code> is equivalent to:</p>\n<pre><code class=\"language-rust\">let mut _tmp0 = S { x: 2 };\nlet v = &amp;mut _tmp0;\n</code></pre>\n<p>The second line of <code>main</code> mutates the value pointed to by <code>v</code>. The same value\nremains accessible through <code>v</code> for the rest of the lifetime of <code>v</code>, which is why\nthe first character printed is <code>3</code>.</p>\n<p>The third line of <code>main</code> mutates a temporary that immediately goes out of scope\nat the semicolon. The second character printed is coming from a brand new <code>S { x: 2 }</code>, so <code>2</code> is printed.</p>\n<p>One additional wrinkle in this code is the concept of namespaces and name\nresolution in Rust. Any name that refers to a <em>type</em> lives in the <em>type\nnamespace</em>, and any name that refers to a <em>value</em> lives in the <em>value\nnamespace</em>. These are two separate sets of names, and the language is structured\nsuch that we can always tell which namespace to look up a name in.</p>\n<p>In the context of the quiz code, the name of the struct <code>S</code> is part of the type\nnamespace and the name of the const <code>S</code> is part of the value namespace. That is\nhow we can have seemingly two different things with the same name in scope at\nthe same time.</p>\n"
  },
  "4": {
    "code": "fn main() {\n    let (.., x, y) = (0, 1, ..);\n    print!(\"{}\", b\"066\"[y][x]);\n}\n",
    "difficulty": 1,
    "answer": "54",
    "hint": "<p><code>..</code> means one thing in an expression and something else in a pattern.</p>\n",
    "explanation": "<p>This question demonstrates two different meanings of <code>..</code>.</p>\n<p>In expression position, <code>..</code> is the syntax for constructing various types of\nranges. Here the expression <code>(0, 1, ..)</code> is a tuple with three elements, the\nthird one having type <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/ops/struct.RangeFull.html\"><code>RangeFull</code></a>.</p>\n<p>On the other hand in a pattern, <code>..</code> is used to mean \"any number of elements\".\nSo the pattern <code>(.., x, y)</code> matches a tuple with 2 or more elements, binding the\nsecond-last one to <code>x</code> and the last one to <code>y</code>.</p>\n<p>Coming out of the first line of <code>main</code>, we have <code>x = 1</code> and <code>y = (..)</code>. Thus the\nvalue printed is going to be <code>b\"066\"[..][1]</code>.</p>\n<p>The expression <code>b\"066\"</code> is a byte-string literal of type <code>&amp;'static [u8; 3]</code>\ncontaining the three ASCII bytes <code>b'0'</code>, <code>b'6'</code>, <code>b'6'</code>.</p>\n<p>When we slice the byte-string with <code>RangeFull</code> we get a dynamically sized slice\n<code>[u8]</code> of length 3. Next we access element <code>1</code> of the slice, which is the byte\n<code>b'6'</code> of type <code>u8</code>. When printed, we see the decimal representation of the byte\nvalue of the ASCII digit 6, which is the number 54.</p>\n"
  },
  "5": {
    "code": "trait Trait {\n    fn p(self);\n}\n\nimpl<T> Trait for fn(T) {\n    fn p(self) {\n        print!(\"1\");\n    }\n}\n\nimpl<T> Trait for fn(&T) {\n    fn p(self) {\n        print!(\"2\");\n    }\n}\n\nfn f(_: u8) {}\nfn g(_: &u8) {}\n\nfn main() {\n    let a: fn(_) = f;\n    let b: fn(_) = g;\n    let c: fn(&_) = g;\n    a.p();\n    b.p();\n    c.p();\n}\n"
  },
  "6": {
    "code": "use std::mem;\n\nfn main() {\n    let a;\n    let a = a = true;\n    print!(\"{}\", mem::size_of_val(&a));\n}\n",
    "difficulty": 1,
    "answer": "0",
    "hint": "<p>There are two variables named <code>a</code>. What is the type of each one?</p>\n",
    "explanation": "<p>There are two variables named <code>a</code>, one shadowing the other. The program is\nequivalent to:</p>\n<pre><code class=\"language-rust\">let a;\nlet b = a = true;\nprint!(\"{}\", mem::size_of_val(&amp;b));\n</code></pre>\n<p>Further, the value being assigned to <code>b</code> is the expression <code>a = true</code>.</p>\n<p>In Rust, assignment expressions always have the value <code>()</code>. Simplified some\nmore, the quiz code is equivalent to:</p>\n<pre><code class=\"language-rust\">let a = true;\nlet b = ();\nprint!(\"{}\", mem::size_of_val(&amp;b));\n</code></pre>\n<p>Refer to the documentation of <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/mem/fn.size_of_val.html\"><code>size_of_val</code></a> for a specification of its\nbehavior, but in this case it is being instantiated with <code>T = ()</code> and we end up\nprinting the value of <code>size_of::&lt;()&gt;()</code>.</p>\n<p><code>()</code> is one example of a <a target=\"_blank\" href=\"https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\"><em>zero-sized type</em></a> or ZST and is represented by\nzero bytes of data at runtime, so the program prints <code>0</code>.</p>\n"
  },
  "7": {
    "code": "#[repr(u8)]\nenum Enum {\n    First,\n    Second,\n}\n\nimpl Enum {\n    fn p(self) {\n        match self {\n            First => print!(\"1\"),\n            Second => print!(\"2\"),\n        }\n    }\n}\n\nfn main() {\n    Enum::p(unsafe {\n        std::mem::transmute(1u8)\n    });\n}\n"
  },
  "8": {
    "code": "macro_rules! m {\n    (==>) => { print!(\"1\"); };\n    (= = >) => { print!(\"2\"); };\n    (== >) => { print!(\"3\"); };\n    (= =>) => { print!(\"4\"); };\n}\n\nfn main() {\n    m!(==>);\n    m!(= = >);\n    m!(== >);\n    m!(= =>);\n}\n",
    "difficulty": 2,
    "answer": "1214",
    "hint": "<p>According to <code>macro_rules!</code>, <code>==</code> is one token and <code>=&gt;</code> is one token.</p>\n",
    "explanation": "<p>Adjacent punctuation characters in the input pattern of a <code>macro_rules!</code> macro\nare grouped according to how those characters are used by native Rust tokens.</p>\n<p><a target=\"_blank\" href=\"https://docs.rs/syn/2/syn/token/index.html#structs\">This page</a> contains a list of the single-character and multi-character\npunctuation tokens involved in the Rust grammar.</p>\n<p>As one example from that list, <code>&lt;&lt;=</code> is a single token because the Rust grammar\nuses that sequence of characters to mean <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/ops/trait.ShlAssign.html\">left shift assignment</a>.\nThus a <code>macro_rules!</code> input rule containing <code>&lt;&lt;=</code> would only match if all three\ncharacters <code>&lt;&lt;=</code> are written consecutively without spaces in the invocation.</p>\n<p>But for example <code>=&lt;&lt;</code> is not a native token in the Rust grammar. The parser of\n<code>macro_rules!</code> will decompose this into Rust tokens according to a greedy\nprocess. <code>=&lt;</code> is also not a native token, so first we would need to match a <code>=</code>\nby itself. Then <code>&lt;&lt;</code> <em>is</em> a native token. Writing <code>=&lt;&lt;</code> in a macro rule behaves\nexactly the same as writing <code>= &lt;&lt;</code>.</p>\n<p>Now let's decompose the rules in the quiz code the same way.</p>\n<ul>\n<li><code>==&gt;</code> decomposes as <code>== &gt;</code>.</li>\n<li><code>= = &gt;</code> is already decomposed into Rust tokens.</li>\n<li><code>== &gt;</code> is already decomposed.</li>\n<li><code>= =&gt;</code> is already decomposed.</li>\n</ul>\n<p>Our macro is the same as if we had written the first rule with a space. The\nthird rule is unreachable.</p>\n<pre><code class=\"language-rust\">macro_rules! m {\n    (== &gt;) =&gt; { print!(\"1\"); };\n    (= = &gt;) =&gt; { print!(\"2\"); };\n    (== &gt;) =&gt; { print!(\"3\"); };\n    (= =&gt;) =&gt; { print!(\"4\"); };\n}\n</code></pre>\n<p>Within <code>main</code>, the first and third lines <em>both</em> match the first macro rule. The\nsecond line matches the second rule and the fourth line matches the fourth rule.\nThe output is <code>1214</code>.</p>\n<p><a target=\"_blank\" href=\"https://github.com/dtolnay/syn\">Procedural macros</a> use a more flexible and powerful macro API and can\nalways distinguish between different spacings of the same characters, such as\n<code>== &gt;</code> vs <code>==&gt;</code>.</p>\n"
  },
  "9": {
    "code": "macro_rules! m {\n    (1) => { print!(\"1\") };\n    ($tt:tt) => { print!(\"2\") };\n}\n\nmacro_rules! e {\n    ($e:expr) => { m!($e) };\n}\n\nmacro_rules! t {\n    ($tt:tt) => { e!($tt); m!($tt); };\n}\n\nfn main() {\n    t!(1);\n}\n",
    "difficulty": 2,
    "answer": "21",
    "hint": "<p>Upon being matched as a <code>$:expr</code>, the matched expression becomes a single opaque\ntoken tree.</p>\n",
    "explanation": "<p>This question involves the behavior of macro matchers as regards matching macro\nmetavariables.</p>\n<p>Starting from the bottom of the quiz code, the invocation <code>t!(1)</code> matches the\nfirst rule of <code>t!</code> and expands to <code>e!(1); m!(1);</code>.</p>\n<p>The invocation <code>e!(1)</code> matches the first rule of <code>e!</code>. As part of this match,\nthe expression <code>1</code> is packaged into an opaque expression token called <code>$e</code>. At\nno subsequent point will it be possible for any <code>macro_rules!</code> macro to look\ninside of <code>$e</code>. All that can be known is that <code>$e</code> is <em>some</em> expression.</p>\n<p>In any case, <code>e!(1)</code> expands to <code>m!($e)</code> where <code>$e</code> is an opaque expression\ncontaining <code>1</code>. That <code>m!($e)</code> <em>does not</em> match the first rule of <code>m!</code> because\n<code>$e</code> is opaque. Instead it matches the second rule of <code>m!</code> and prints <code>2</code>.</p>\n<p>After <code>e!(1)</code> there is an invocation <code>m!(1)</code> coming from the expansion of <code>t!</code>.\nThat one <em>does</em> match the first rule of <code>m!</code> and prints <code>1</code>. The output of this\nprogram is <code>21</code>.</p>\n<p>Most fragment specifiers have this behavior of becoming opaque token boxes, but\nsome do not. Specifiers that are opaque once matched:</p>\n<ul>\n<li><code>$:block</code></li>\n<li><code>$:expr</code></li>\n<li><code>$:item</code></li>\n<li><code>$:literal</code></li>\n<li><code>$:meta</code></li>\n<li><code>$:pat</code></li>\n<li><code>$:path</code></li>\n<li><code>$:stmt</code></li>\n<li><code>$:ty</code></li>\n</ul>\n<p>The rest of the specifiers do not become opaque and can be inspected by\nsubsequent rules:</p>\n<ul>\n<li><code>$:ident</code></li>\n<li><code>$:lifetime</code></li>\n<li><code>$:tt</code></li>\n</ul>\n<p>For example:</p>\n<pre><code class=\"language-rust\">macro_rules! m {\n    ('a) =&gt; {};\n}\n\nmacro_rules! l {\n    ($l:lifetime) =&gt; {\n        // $l is not opaque.\n        m!($l);\n    }\n}\n\nl!('a);\n</code></pre>\n"
  },
  "10": {
    "code": "trait Trait {\n    fn f(&self);\n}\n\nimpl<'a> dyn Trait + 'a {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for bool {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    Trait::f(&true);\n    Trait::f(&true as &dyn Trait);\n    <_ as Trait>::f(&true);\n    <_ as Trait>::f(&true as &dyn Trait);\n    <bool as Trait>::f(&true);\n    <dyn Trait as Trait>::f(&true as &dyn Trait);\n}\n",
    "difficulty": 2,
    "answer": "222222",
    "hint": "<p>This won't help you answer the question but may help feel better: the quiz\nauthor was also stumped by this one.</p>\n",
    "explanation": "<p>This question contains a trait method <code>Trait::f</code> as well as an inherent method\n<code>f</code> on the trait object type <code>dyn Trait</code>.</p>\n<p><em>As far as I know,</em> given that these names shadow each other, the inherent\nmethod is literally uncallable. There is currently no syntax in Rust for calling\nthe inherent <code>f</code> on <code>dyn Trait</code>.</p>\n<p>One additional syntax to try would be:</p>\n<pre><code class=\"language-rust\">&lt;dyn Trait&gt;::f(&amp;true);\n&lt;dyn Trait&gt;::f(&amp;true as &amp;dyn Trait);\n</code></pre>\n<p>If the trait method were named something different, both of these would call the\ninherent method. If the inherent method were named something different, both of\nthese would call the trait method. But if the trait method and the inherent\nmethod are both <code>f</code> then the compiler reports an ambiguity.</p>\n<pre><code>error[E0034]: multiple applicable items in scope\n  --&gt; questions/010.rs:18:5\n   |\n18 |     &lt;dyn Trait&gt;::f(&amp;true);\n   |     ^^^^^^^^^^^^^^ multiple `f` found\n   |\nnote: candidate #1 is defined in an impl for the type `dyn Trait`\n  --&gt; questions/010.rs:6:5\n   |\n6  |     fn f(&amp;self) {\n   |     ^^^^^^^^^^^\nnote: candidate #2 is defined in the trait `Trait`\n  --&gt; questions/010.rs:2:5\n   |\n2  |     fn f(&amp;self);\n   |     ^^^^^^^^^^^^\n   = help: to disambiguate the method call, write `Trait::f(...)` instead\n</code></pre>\n<p>Maybe some day it will be possible to disambiguate a call to an inherent method\non a trait object shadowed by a trait method. For now, the quiz code prints\n<code>222222</code>.</p>\n"
  },
  "11": {
    "code": "fn f<'a>() {}\nfn g<'a: 'a>() {}\n\nfn main() {\n    let pf = f::<'static> as fn();\n    let pg = g::<'static> as fn();\n    print!(\"{}\", (pf == pg) as u8);\n}\n",
    "difficulty": 3,
    "answer": "error",
    "hint": "<p>The way that <code>f</code> and <code>g</code> are written is not interchangeable.</p>\n",
    "explanation": "<p>Function pointer comparison is generally a Bad Idea. It is easily possible to\nget nonsensical behavior in optimized builds. For a jaw-dropping example of such\nbehavior, check out <a target=\"_blank\" href=\"https://github.com/rust-lang/rust/issues/54685\">rust-lang/rust#54685</a> in which <code>x == y</code> is both true and\nnot true at the same time.</p>\n<p>That said, the quiz code in this question fails to compile. Here is the compiler\noutput:</p>\n<pre><code>error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n --&gt; questions/011.rs:5:18\n  |\n5 |     let pf = f::&lt;'static&gt; as fn();\n  |                  ^^^^^^^\n  |\nnote: the late bound lifetime parameter is introduced here\n --&gt; questions/011.rs:1:18\n  |\n1 | fn f&lt;'a&gt;() {}\n  |      ^^\n</code></pre>\n<p>Generic parameters can be either early bound or late bound. Currently (and for\nthe foreseeable future) type parameters are always early bound, but lifetime\nparameters can be either early or late bound.</p>\n<p>Early bound parameters are determined by the compiler during monomorphization.\nSince type parameters are always early bound, you cannot have a value whose\ntype has an unresolved type parameter. For example:</p>\n<pre><code>fn m&lt;T&gt;() {}\n\nfn main() {\n    let m1 = m::&lt;u8&gt;; // ok\n    let m2 = m; // error: cannot infer type for `T`\n}\n</code></pre>\n<p>However, this is often allowed for lifetime parameters:</p>\n<pre><code>fn m&lt;'a&gt;(_: &amp;'a ()) {}\n\nfn main() {\n    let m1 = m; // ok even though 'a isn't provided\n}\n</code></pre>\n<p>Since the actual choice of lifetime <code>'a</code> depends on how it is called, we are\nallowed to omit the lifetime parameter and it will be determined at the call\nsite. The lifetime can even be different for each time it gets called.</p>\n<p>For this reason, we cannot specify the lifetime on this function until it is\ncalled:</p>\n<pre><code>// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\nlet m2 = m::&lt;'static&gt;;\n</code></pre>\n<p>We may not even ask the borrow checker to infer it too soon:</p>\n<pre><code>// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\nlet m3 = m::&lt;'_&gt;;\n</code></pre>\n<p>The idea of late bound parameters overlaps considerably with a feature of Rust\ncalled \"higher ranked trait bounds\" (HRTB). This is a mechanism for expressing\nthat bounds on a trait's parameters are late bound. Currently this is limited to\nlifetime parameters, but the same idea exists in other languages (such as\nHaskell) for type parameters, which is where the term \"higher ranked\" comes\nfrom.</p>\n<p>The syntax to express a HRTB for lifetimes uses the <code>for</code> keyword. To express\nthe type of <code>m1</code> above, we could have written:</p>\n<pre><code>let m1: impl for&lt;'r&gt; Fn(&amp;'r ()) = m;\n</code></pre>\n<p>You can think of this as meaning: \"There is a lifetime but we don't need to\nknow what it is just yet\".</p>\n<p>Late bound lifetimes are always unbounded; there is no syntax for expressing a\nlate bound lifetime that must outlive some other lifetime.</p>\n<pre><code>error: lifetime bounds cannot be used in this context\n --&gt; src/main.rs:5:20\n  |\n5 |     let _: for&lt;'b: 'a&gt; fn(&amp;'b ());\n  |                    ^^\n</code></pre>\n<p>Lifetimes on <em>data types</em> are always early bound except when the developer has\nexplicitly used the HRTB <code>for</code> syntax. On <em>functions</em>, lifetimes are late bound\nby default but can be early bound if:</p>\n<ul>\n<li>\n<p>The lifetime is declared outside the function signature, e.g. in an associated\nmethod of a struct it could be from the struct itself; or</p>\n</li>\n<li>\n<p>The lifetime parameter is bounded below by some other lifetime that it must\noutlive. As we've seen, this constraint is not expressible in the HRTB that\nwould be involved in late binding the lifetime.</p>\n</li>\n</ul>\n<p>By these rules, the signature <code>fn f&lt;'a&gt;()</code> has a late bound lifetime parameter\nwhile the signature <code>fn g&lt;'a: 'a&gt;()</code> has an early bound lifetime parameter —\neven though the constraint here is ineffectual.</p>\n<p>Ordinarily these distinctions are compiler-internal terminology that Rust\nprogrammers are not intended to know about or think about in everyday code.\nThere are only a few edge cases where this aspect of the type system becomes\nobservable in the surface language, such as in the original quiz code.</p>\n"
  },
  "12": {
    "code": "struct D(u8);\n\nimpl Drop for D {\n    fn drop(&mut self) {\n        print!(\"{}\", self.0);\n    }\n}\n\nstruct S {\n    d: D,\n    x: u8,\n}\n\nfn main() {\n    let S { x, .. } = S {\n        d: D(1),\n        x: 2,\n    };\n    print!(\"{}\", x);\n\n    let S { ref x, .. } = S {\n        d: D(3),\n        x: 4,\n    };\n    print!(\"{}\", x);\n}\n",
    "difficulty": 1,
    "answer": "1243",
    "hint": "<p>The pattern <code>S { ref x, .. }</code> borrows a binding <code>x</code> from the owner of a value of\ntype <code>S</code>.</p>\n",
    "explanation": "<p>This question involves drop-placement. Where does <code>D</code> get dropped?</p>\n<p>In the first <code>let</code>-binding, we <a target=\"_blank\" href=\"https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values\">destructure</a> a value of type <code>S</code> into its field\n<code>x</code> of type <code>u8</code> as well as <code>..</code> which represents \"the rest of <code>S</code>\". The part\nthat is the rest of <code>S</code> is dropped immediately at that point because it no\nlonger has an owner.</p>\n<p>In the second <code>let</code>-binding, we borrow a field <code>x</code> from the owner of a value of\ntype <code>S</code>. The whole value of type <code>S</code> remains in scope during the time that its\nfield <code>x</code> is borrowed, and goes out of scope at the close curly brace of <code>main</code>.</p>\n<p>The output is <code>1243</code>.</p>\n"
  },
  "13": {
    "code": "struct S;\n\nfn main() {\n    let [x, y] = &mut [S, S];\n    let eq = x as *mut S == y as *mut S;\n    print!(\"{}\", eq as u8);\n}\n",
    "difficulty": 1,
    "answer": "1",
    "hint": "<p>Is it okay for two mutable references to point to the same memory location? What\ncould go wrong?</p>\n",
    "explanation": "<p>In this code, <code>S</code> is a <a target=\"_blank\" href=\"https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\">zero sized type</a> or ZST. Zero sized types are\ncompile-time concepts that disappear during compilation and have a runtime\nrepresentation of zero bytes.</p>\n<p>The first line of <code>main</code> creates a local value of type <code>[S; 2]</code>. Let's refer to\nthat temporary as <code>tmp</code>. The <code>let</code>-binding binds two references into <code>tmp</code>, <code>x</code>\nreferring to <code>&amp;mut tmp[0]</code> and <code>y</code> referring to <code>&amp;mut tmp[1]</code>.</p>\n<p>On the second line of <code>main</code> we want to know whether <code>x</code> and <code>y</code> as pointers\nhave the same value.</p>\n<p>The array type <code>[S; 2]</code> is itself a zero sized type. You can confirm this by\nprinting the value of <code>std::mem::size_of::&lt;[S; 2]&gt;()</code>. Indeed the first and\nsecond element of the array have the same memory address.</p>\n<p>Ordinarily having multiple mutable references to the same memory location would\nnot be safe, but in the case of mutable references to zero sized types,\ndereferencing is a no-op so there is no way to violate any memory safety\nguarantees this way.</p>\n"
  },
  "14": {
    "code": "trait Trait: Sized {\n    fn is_reference(self) -> bool;\n}\n\nimpl<'a, T> Trait for &'a T {\n    fn is_reference(self) -> bool {\n        true\n    }\n}\n\nfn main() {\n    match 0.is_reference() {\n        true => print!(\"1\"),\n        false => print!(\"0\"),\n    }\n\n    match '?'.is_reference() {\n        true => print!(\"1\"),\n        false => {\n            impl Trait for char {\n                fn is_reference(self) -> bool {\n                    false\n                }\n            }\n            print!(\"0\")\n        }\n    }\n}\n",
    "difficulty": 1,
    "answer": "10",
    "hint": "<p>Trait method auto-ref is covered in <a target=\"_blank\" href=\"https://stackoverflow.com/a/28552082/6086311\">this Stack Overflow answer</a>.</p>\n",
    "explanation": "<p>Trait impls anywhere in a program are always in scope, so there is no\nsignificance to the <code>impl Trait for char</code> being written inside of a block of\ncode. In particular, that impl is visible throughout the whole program, not just\nwithin the block containing the impl.</p>\n<p>This question relates to the behavior of trait method auto-ref which is covered\nin <a target=\"_blank\" href=\"https://stackoverflow.com/a/28552082/6086311\">this Stack Overflow answer</a>.</p>\n<p>The call to <code>0.is_reference()</code> observes that there is no implementation of\n<code>Trait</code> for an integer type that we could call directly. Method resolution\ninserts an auto-ref, effectively evaluating <code>(&amp;0).is_reference()</code>. This time the\ncall matches <code>impl&lt;'a, T&gt; Trait for &amp;'a T</code> and prints <code>1</code>.</p>\n<p>The call to <code>'?'.is_reference()</code> instead finds <code>impl Trait for char</code>, printing\n<code>0</code>.</p>\n"
  },
  "15": {
    "code": "trait Trait {\n    fn f(&self);\n}\n\nimpl Trait for u32 {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl<'a> Trait for &'a i32 {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    let x = &0;\n    x.f();\n}\n",
    "difficulty": 1,
    "answer": "1",
    "hint": "<p>What type would type inference infer for <code>x</code>?</p>\n",
    "explanation": "<p>During type inference the variable <code>x</code> has type <code>&amp;{integer}</code>, a reference to\nsome as yet undetermined integer type.</p>\n<p>If we want to resolve the trait method call <code>Trait::f(x)</code>, we find that its\nargument <code>x</code> must be of type <code>&amp;Self</code> for some type <code>Self</code> that implements\n<code>Trait</code>. We find that inferring <code>0: u32</code> satisfies both the constraint that\n<code>u32</code> is an integer as well as <code>u32</code> implements <code>Trait</code>, so the method call ends\nup calling <code>&lt;u32 as Trait&gt;::f(x)</code> and prints <code>1</code>.</p>\n<p>Trait method resolution is covered in more detail in <a target=\"_blank\" href=\"https://stackoverflow.com/a/28552082/6086311\">this Stack Overflow\nanswer</a>.</p>\n"
  },
  "16": {
    "code": "fn main() {\n    let mut x = 4;\n    --x;\n    print!(\"{}{}\", --x, --x);\n}\n",
    "difficulty": 1,
    "answer": "44",
    "hint": "<p>The set of operators supported by Rust is documented in <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/ops/index.html\"><code>std::ops</code></a>.</p>\n",
    "explanation": "<p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The\nRust language design FAQ (no longer available online) used to touch on the\nreason:</p>\n<blockquote>\n<p><strong>Why doesn't Rust have increment and decrement operators?</strong><br>\nPreincrement and postincrement (and the decrement equivalents), while\nconvenient, are also fairly complex. They require knowledge of evaluation\norder, and often lead to subtle bugs and undefined behavior in C and C++. <code>x = x + 1</code> or <code>x += 1</code> is only slightly longer, but unambiguous.</p>\n</blockquote>\n<p>In the absence of a decrement operator, <code>--x</code> is parsed as <code>-(-x)</code>. In the case\nof <code>x = 4</code> this would be <code>-(-4)</code> which is <code>4</code>. The program is equivalent to:</p>\n<pre><code class=\"language-rust\">fn main() {\n    let mut x = 4;\n    4;\n    print!(\"{}{}\", 4, 4);\n}\n</code></pre>\n"
  },
  "17": {
    "code": "fn main() {\n    let mut a = 5;\n    let mut b = 3;\n    print!(\"{}\", a-- - --b);\n}\n",
    "difficulty": 1,
    "answer": "2",
    "hint": "<p>The set of operators supported by Rust is documented in <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/ops/index.html\"><code>std::ops</code></a>.</p>\n",
    "explanation": "<p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The\nRust language design FAQ (no longer available online) used to touch on the\nreason:</p>\n<blockquote>\n<p><strong>Why doesn't Rust have increment and decrement operators?</strong><br>\nPreincrement and postincrement (and the decrement equivalents), while\nconvenient, are also fairly complex. They require knowledge of evaluation\norder, and often lead to subtle bugs and undefined behavior in C and C++. <code>x = x + 1</code> or <code>x += 1</code> is only slightly longer, but unambiguous.</p>\n</blockquote>\n<p>In the absence of postfix and prefix decrement operators, <code>a-- - --b</code> is parsed\nas <code>a - (-(-(-(-b))))</code>. In the case of <code>a = 5</code> and <code>b = 3</code> the value of this\nexpression is <code>5 - 3</code> which is <code>2</code>.</p>\n"
  },
  "18": {
    "code": "struct S {\n    f: fn(),\n}\n\nimpl S {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let print2 = || print!(\"2\");\n    S { f: print2 }.f();\n}\n",
    "difficulty": 1,
    "answer": "1",
    "hint": "<p>The call <code>.f()</code> resolves to either the field <code>f</code> or the inherent method <code>f</code>. How\nwould you write a call to the other one?</p>\n",
    "explanation": "<p>A call that looks like <code>.f()</code> always resolves to a method, in this case the\ninherent method <code>S::f</code>. If there were no method <code>f</code> in scope, a call like this\nwould fail to compile even if a field <code>f</code> exists and contains a function\npointer.</p>\n<p>To call the function pointer stored in field <code>f</code>, we would need to write\nparentheses around the field access:</p>\n<pre><code class=\"language-rust\">fn main() {\n    let print2 = || print!(\"2\");\n    (S { f: print2 }.f)();\n}\n</code></pre>\n"
  },
  "19": {
    "code": "struct S;\n\nimpl Drop for S {\n    fn drop(&mut self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let s = S;\n    let _ = s;\n    print!(\"2\");\n}\n",
    "difficulty": 1,
    "answer": "21",
    "hint": "<p>Does <code>s</code> get moved?</p>\n",
    "explanation": "<p>The relevant line is <code>let _ = s</code>. If this line does not move <code>s</code> then <code>s</code> will\ncontinue to live until the close curly brace and the program would print <code>21</code>.\nBut if this line does move <code>s</code>, without binding it, then the moved value of type\n<code>S</code> would be dropped immediately and the program would print <code>12</code>.</p>\n<p>In fact <code>s</code> does not get moved and the output is <code>21</code>.</p>\n"
  },
  "20": {
    "code": "fn return1() {\n    if (return { print!(\"1\") }) {\n    }\n}\n\nfn return2() {\n    if return { print!(\"2\") } {\n    }\n}\n\nfn break1() {\n    loop {\n        if (break { print!(\"1\") }) {\n        }\n    }\n}\n\nfn break2() {\n    loop {\n        if break { print!(\"2\") } {\n        }\n    }\n}\n\nfn main() {\n    return1();\n    return2();\n    break1();\n    break2();\n}\n",
    "difficulty": 2,
    "answer": "121",
    "hint": "<p>The Rust grammar involving <code>break</code> is different from the grammar involving\n<code>return</code>.</p>\n",
    "explanation": "<p>Let's work through the functions one at a time.</p>\n<ul>\n<li>\n<p><code>fn return1</code></p>\n<p>The condition of the <code>if</code>-statement is parsed as a return-expression that\nreturns the value <code>{ print!(\"1\") }</code> of type <code>()</code>. The value needs to be\nevaluated prior to being returned so this function prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>fn return2</code></p>\n<p>This function is parsed the same as <code>return1</code>. The <code>return</code> keyword eagerly\nconsumes a trailing return value, even if the return value begins with a\ncurly brace, and even in the condition of an <code>if</code>-statement where curly\nbraces such as in a struct literal would ordinarly not be accepted. This\nfunction prints <code>2</code>.</p>\n</li>\n<li>\n<p><code>fn break1</code></p>\n<p>The condition of the <code>if</code>-statement is a break-with-value expression that\nbreaks out of the enclosing loop with the value <code>{ print!(\"1\") }</code> of type\n<code>()</code>. Similar to <code>return1</code>, in order to break with this value the value\nneeds to be evaluated and this function prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>fn break2</code></p>\n<p>Here we observe a difference between the grammar of <code>break</code> and the grammar\nof <code>return</code>. Unlike <code>return</code>, the <code>break</code> keyword in the condition of this\n<code>if</code>-statement <em>does not</em> eagerly parse a value that begins with a curly\nbrace. This code is parsed as:</p>\n<pre><code class=\"language-rust\">loop {\n    if break {\n        print!(\"2\")\n    }\n    {}\n}\n</code></pre>\n<p>We break out of the loop before executing the print, so this function does\nnot print anything.</p>\n<p>I believe the reason for the difference between <code>return</code> and <code>break</code> is that\nreturning a value was obviously supported at Rust 1.0 and well before, but\nbreak-with-value was introduced fairly late, in <a target=\"_blank\" href=\"https://blog.rust-lang.org/2017/07/20/Rust-1.19.html\">Rust 1.19</a>. The code in\n<code>break2</code> was perfectly legal Rust code prior to Rust 1.19 so we cannot\nchange its behavior when implementing the break-with-value language feature.</p>\n<p>It is possible that a future Edition would adjust the two grammars to align\nwith each other.</p>\n</li>\n</ul>\n<p>The output from <code>main</code> is <code>121</code>.</p>\n"
  },
  "21": {
    "code": "trait Trait {\n    fn f(&self);\n}\n\nimpl<F: FnOnce() -> bool> Trait for F {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for () {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    let x = || { (return) || true; };\n    x().f();\n\n    let x = loop { (break) || true; };\n    x.f();\n\n    let x = || { return (|| true); };\n    x().f();\n\n    let x = loop { break (|| true); };\n    x.f();\n\n    let x = || { return || true; };\n    x().f();\n\n    let x = loop { break || true; };\n    x.f();\n}\n",
    "difficulty": 2,
    "answer": "221111",
    "hint": "<p>The <code>break</code> and <code>return</code> keywords have the same grammar in this question.</p>\n",
    "explanation": "<p>We want to know whether each possible parenthesization of <code>return || true;</code> and\n<code>break || true;</code> evaluates to the closure <code>|| true</code> or to the unit value <code>()</code>.</p>\n<ul>\n<li>\n<p><code>let x = || { (return) || true; };</code></p>\n<p>On this line, <code>x</code> is a closure that returns <code>()</code>. It is equivalent to <code>let x   = || {}</code>. When we call <code>x().f()</code>, the method <code>f</code> resolves to <code>impl Trait for   ()</code> which prints <code>2</code>.</p>\n<p>The type of the <em>expression</em> <code>(return)</code> is the primitive <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/primitive.never.html\">never</a> type,\nusually written as <code>!</code>. It is legal to compute <code>! || true</code> because <code>!</code> can\nfill in for any type, in this case bool. The expression <code>! || true</code> is a\nlogical-OR with bool on both the left-hand side and right-hand side.</p>\n<p>The behavior of <code>!</code> of filling in for any type is what allows us to write:</p>\n<pre><code class=\"language-rust\">fn f() -&gt; bool {\n    unimplemented!()\n}\n</code></pre>\n<p>in which the type of <code>unimplemented!()</code>, since it panics without evaluating\nto any value, is also <code>!</code>.</p>\n</li>\n<li>\n<p><code>let x = loop { (break) || true; };</code></p>\n<p>Similar to <code>(return)</code>, the type of <code>(break)</code> is the never type <code>!</code>. This\ncode breaks out of the loop with the implicit value <code>()</code>, so <code>x</code> is of type\n<code>()</code>. Calling <code>x.f()</code> will print <code>2</code>.</p>\n</li>\n<li>\n<p><code>let x = || { return (|| true); };</code></p>\n<p>On this line <code>x</code> is a closure that returns a closure that returns <code>true</code>.\nYou could write <code>x()()</code> and that would be <code>true</code>.</p>\n<p>The quiz code calls <code>x().f()</code> which resolves to <code>impl&lt;F&gt; Trait for F where   F: FnOnce() -&gt; bool</code>. That trait impl prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>let x = loop { break (|| true); };</code></p>\n<p>This is a loop containing a break-with-value expression. The argument of the\n<code>break</code> becomes the value of the enclosing <code>loop</code>. This code is equivalent\nto <code>let x = || true</code>.</p>\n<p>When we call <code>x.f()</code> it uses the <code>FnOnce</code> impl of <code>Trait</code> which prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>let x = || { return || true; };</code></p>\n<p>Now we arrive at the meat of this quiz question. Is <code>return || true</code> parsed\nthe same as <code>(return) || true</code> or as <code>return (|| true)</code>?</p>\n<p>It turns out to be the latter, so <code>x</code> is a closure that returns a closure\nthat returns true. <code>x().f()</code> prints <code>1</code>.</p>\n</li>\n<li>\n<p><code>let x = loop { break || true; };</code></p>\n<p>Similar question here, is this <code>(break) || true</code> or <code>break (|| true)</code>?</p>\n<p>The break-with-value language feature was added to Rust more than two years\nafter 1.0, in <a target=\"_blank\" href=\"https://blog.rust-lang.org/2017/07/20/Rust-1.19.html\">Rust 1.19</a>. Prior to break-with-value, <code>break || true</code> was\nperfectly legal Rust code that parsed as <code>(break) || true</code>.</p>\n<p>In Rust 1.19 the behavior of this code was unintentionally broken by the\nlanguage such that now it parses as <code>break (|| true)</code> and the printed value\nis <code>1</code>.</p>\n<p>If we had noticed this change in meaning during the development of Rust\n1.19, we may have adjusted the parsing to preserve the meaning of existing\ncode. Unfortunately doing so would result in a grammar that behaves\ndifferently between <code>return</code> and <code>break</code> for no justifiable reason other\nthan an accident of history.</p>\n<p>Or it is possible we would have ruled this an edge case of syntax that would\nnever appear in real code, used <a target=\"_blank\" href=\"https://github.com/rust-lang-nursery/crater\">Crater</a> to validate that hypothesis, and\nbroken the behavior intentionally.</p>\n</li>\n</ul>\n<p>The total output from <code>main</code> is <code>221111</code>.</p>\n"
  },
  "22": {
    "code": "macro_rules! m {\n    ($a:tt) => { print!(\"1\") };\n    ($a:tt $b:tt) => { print!(\"2\") };\n    ($a:tt $b:tt $c:tt) => { print!(\"3\") };\n    ($a:tt $b:tt $c:tt $d:tt) => { print!(\"4\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt) => { print!(\"5\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) => { print!(\"6\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) => { print!(\"7\") };\n}\n\nfn main() {\n    m!(-1);\n    m!(-1.);\n    m!(-1.0);\n    m!(-1.0e1);\n    m!(-1.0e-1);\n}\n",
    "difficulty": 1,
    "answer": "22222",
    "hint": "<p>The macro is counting how many \"tokens\" are in its input.</p>\n",
    "explanation": "<p>All five invocations of <code>m!</code> pass two tokens as input: a minus sign followed by\nan integer or floating point literal token.</p>\n<p>The floating point literals <code>1.</code>, <code>1.0</code>, <code>1.0e1</code>, <code>1.0e-1</code> are each a single\natomic token.</p>\n<p>The parser built into the Rust compiler always parses a negative sign as a\nseparate token from the numeric literal that is being negating. However, it is\npossible for a user-defined parser within a <a target=\"_blank\" href=\"https://github.com/dtolnay/syn\">procedural macro</a> to construct a\nnegative number as a single token by passing a negative integer or negative\nfloating point value to one of the constructors of <a target=\"_blank\" href=\"https://doc.rust-lang.org/proc_macro/struct.Literal.html\"><code>proc_macro::Literal</code></a>. If\nsuch a negative literal ends up in the input of a subsequent procedural macro\ninvocation, it is up to the compiler whether to rewrite into a pair of tokens or\nkeep them as one.</p>\n<p>The behavior of the compiler's parser is observable in the surface language as\nwell, not only in macros. For example the following code prints <code>-81</code> because\nthe expression is parsed as <code>-(3i32.pow(4))</code> rather than <code>(-3i32).pow(4)</code>.</p>\n<pre><code class=\"language-rust\">fn main() {\n    let n = -3i32.pow(4);\n    println!(\"{}\", n);\n}\n</code></pre>\n"
  },
  "23": {
    "code": "trait Trait {\n    fn f(&self);\n    fn g(&self);\n}\n\nstruct S;\n\nimpl S {\n    fn f(&self) {\n        print!(\"1\");\n    }\n\n    fn g(&mut self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for S {\n    fn f(&self) {\n        print!(\"2\");\n    }\n\n    fn g(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    S.f();\n    S.g();\n}\n",
    "difficulty": 2,
    "answer": "12",
    "hint": "<p>I can't help you with this one. This is a pretty arbitrary choice made by the\nlanguage. Try all the possibilities!</p>\n",
    "explanation": "<p><code>S.f()</code> calls the inherent method <code>f</code>. If an inherent method and a trait method\nhave the same name and receiver type, plain method call syntax will always\nprefer the inherent method. The caller would need to write <code>Trait::f(&amp;S)</code> or <code>&lt;S as Trait&gt;::f(&amp;S)</code> in order to call the trait method.</p>\n<p>It is important for macro authors to be aware of this. Macro-generated code\ntypically should not use method call syntax to invoke trait methods on types\ndefined by the user. Those calls could get unintentionally hijacked by inherent\nmethods having the same name as the trait method.</p>\n<p>On the other hand, <code>S.g()</code> calls the trait method <code>g</code>. Auto-ref during method\nresolution always prefers making something into <code>&amp;</code> over making it into <code>&amp;mut</code>\nwhere either one would work.</p>\n<p>See <a target=\"_blank\" href=\"https://stackoverflow.com/a/28552082/6086311\">this Stack Overflow answer</a> for a more detailed explanation of auto-ref\nduring method resolution.</p>\n"
  },
  "24": {
    "code": "fn main() {\n    let x: u8 = 1;\n    const K: u8 = 2;\n\n    macro_rules! m {\n        () => {\n            print!(\"{}{}\", x, K);\n        };\n    }\n\n    {\n        let x: u8 = 3;\n        const K: u8 = 4;\n\n        m!();\n    }\n}\n",
    "difficulty": 1,
    "answer": "14",
    "hint": "<p>Hygiene in <code>macro_rules!</code> only applies to local variables.</p>\n",
    "explanation": "<p>This program prints <code>14</code> because hygiene in <code>macro_rules!</code> only applies to local\nvariables.</p>\n<p>You can imagine hygiene as a way of assigning a color to each mention of the\nname of a local variable, allowing for there to be multiple distinguishable\nlocal variables in scope simultaneously with the same name.</p>\n<p>At the top of <code>main</code>, suppose we consider the name of the local variable <code>x</code> to\nbe a purple <code>x</code>. The name of the constant <code>K</code> is just plain <code>K</code>, as constants\nare considered items rather than local variables (you can place items outside of\na function body; you cannot place local variables outside of a function body).</p>\n<pre><code>let <b style=\"background-color:mediumpurple;color:white\">x</b>: u8 = 1;\nconst <b>K</b>: u8 = 2;</code></pre>\n<p>Continuing down the body of <code>main</code>, within the declaration of the macro <code>m!</code>\nthere are identifiers <code>x</code> and <code>K</code> being used. Since there is a local variable\n<code>x</code> in scope, the use of the identifier <code>x</code> within the macro body picks up the\nsame color as the local variable <code>x</code>. There is no local variable <code>K</code> in scope so\nthe <code>K</code> within the declaration of the macro is assigned some new color, say\norange.</p>\n<pre><code>macro_rules! m {\n    () => {\n        print!(\"{}{}\", <b style=\"background-color:mediumpurple;color:white\">x</b>, <b style=\"background-color:coral;color:white\">K</b>);\n    };\n}</code></pre>\n<p>Next we enter a new scope (delimited by curly braces) containing another <code>x</code> and\n<code>K</code>. Every new local variable always introduces a new color so let's call this\n<code>x</code> blue. The const again is not a local variable so no color is assigned to\n<code>K</code>.</p>\n<pre><code>{\n    let <b style=\"background-color:dodgerblue;color:white\">x</b>: u8 = 3;\n    const <b>K</b>: u8 = 4;\n\n    m!();\n}</code></pre>\n<p>When <code>m!()</code> expands, the expanded code refers to a purple <code>x</code> and an orange <code>K</code>.\nThe purple <code>x</code> is distinguishable from the blue <code>x</code> -- the value of the purple\n<code>x</code> is printed which is <code>1</code>. As for the <code>K</code>, an unhygienic (uncolored) <code>K</code> is\nallowed to act like any color. The second <code>K</code> is shadowing the first one. It\ngets picked up when looking for an orange <code>K</code> and its value is printed, which is\n<code>4</code>.</p>\n<p>So the output of the quiz code is <code>14</code>.</p>\n"
  },
  "25": {
    "code": "use std::fmt::{self, Display};\n\nstruct S;\n\nimpl Display for S {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"1\")\n    }\n}\n\nimpl Drop for S {\n    fn drop(&mut self) {\n        print!(\"2\");\n    }\n}\n\nfn f() -> S {\n    S\n}\n\nfn main() {\n    let S = f();\n    print!(\"{}\", S);\n}\n",
    "difficulty": 1,
    "answer": "212",
    "hint": "<p>Figure out what values are owned by which variables where. A value is dropped\nwhen it no longer has an owner.</p>\n",
    "explanation": "<p>This program prints <code>212</code>.</p>\n<p>No value of type <code>S</code> gets dropped within the body of function <code>f</code>. The function\n<code>f</code> conjures an <code>S</code> and returns ownership of it to the caller of <code>f</code>; the caller\ndetermines when to drop the <code>S</code> of which it received ownership.</p>\n<p>On the first line of <code>main</code>, we call <code>f()</code> and perform an infallible match that\nbinds no new variables. As no variables are declared on this line, there is no\nvariable that could be the owner of the <code>S</code> returned by <code>f()</code> so that <code>S</code> is\ndropped at that point, printing <code>2</code>. The <code>S</code> in <code>let S = f()</code> is a unit struct\npattern (not a variable name) that matches a value of type <code>S</code> via\n<a target=\"_blank\" href=\"https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values\">destructuring</a> but does not bind the value to any variable.</p>\n<p>The second line of <code>main</code> conjures a new <code>S</code>, prints it, and drops it at the\nsemicolon.</p>\n"
  },
  "26": {
    "code": "fn main() {\n    let input = vec![1, 2, 3];\n\n    let parity = input\n        .iter()\n        .map(|x| {\n            print!(\"{}\", x);\n            x % 2\n        });\n\n    for p in parity {\n        print!(\"{}\", p);\n    }\n}\n",
    "difficulty": 1,
    "answer": "112031",
    "hint": "<p>Refer to the documentation of the <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\"><code>Iterator</code></a> trait.</p>\n",
    "explanation": "<p>As described in the documentation of the <a target=\"_blank\" href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map\"><code>Iterator::map</code></a> method, the map\noperation is performed lazily. The closure provided as an argument to <code>map</code> is\nonly invoked as values are consumed from the resulting iterator. The closure is\nnot applied eagerly to the entire input stream up front.</p>\n<p>In this code, the <code>for</code> loop is what drives the iteration. For each element\nconsumed from the <code>parity</code> iterator, our closure needs to be evaluated one time.\nThus the output will alternate between numbers printed by the closure and\nnumbers printed by the loop body.</p>\n"
  },
  "27": {
    "code": "trait Base {\n    fn method(&self) {\n        print!(\"1\");\n    }\n}\n\ntrait Derived: Base {\n    fn method(&self) {\n        print!(\"2\");\n    }\n}\n\nstruct BothTraits;\nimpl Base for BothTraits {}\nimpl Derived for BothTraits {}\n\nfn dynamic_dispatch(x: &dyn Base) {\n    x.method();\n}\n\nfn static_dispatch<T: Base>(x: T) {\n    x.method();\n}\n\nfn main() {\n    dynamic_dispatch(&BothTraits);\n    static_dispatch(BothTraits);\n}\n",
    "difficulty": 1,
    "answer": "11",
    "hint": "<p><code>Base::method</code> and <code>Derived::method</code> happen to have the same name but are\notherwise unrelated methods. One does not override the other.</p>\n",
    "explanation": "<p>The two traits <code>Base</code> and <code>Derived</code> each define a trait method called <code>method</code>.\nThese methods happen to have the same name but are otherwise unrelated methods\nas explained below.</p>\n<p>Both traits provide a default implementation of their trait method. Default\nimplementations are conceptually copied into each trait impl that does not\nexplicitly define the same method. In this case for example <code>impl Base for BothTraits</code> does not provide its own implementation of <code>Base::method</code>, which\nmeans the implementation of <code>Base</code> for <code>BothTraits</code> will use the default\nbehavior defined by the trait i.e. <code>print!(\"1\")</code>.</p>\n<p>Additionally, <code>Derived</code> has <code>Base</code> as a <em>supertrait</em> which means that every type\nthat implements <code>Derived</code> is also required to implement <code>Base</code>. The two trait\nmethods are unrelated despite having the same name -- thus any type that\nimplements <code>Derived</code> will have an implementation of <code>Derived::method</code> as well as\nan implementation of <code>Base::method</code> and the two are free to have different\nbehavior. Supertraits are not inheritance! Supertraits are a constraint that if\nsome trait is implemented, some other trait must also be implemented.</p>\n<p>Let's consider what happens in each of the two methods called from <code>main</code>.</p>\n<ul>\n<li>\n<p><code>dynamic_dispatch(&amp;BothTraits)</code></p>\n<p>The argument <code>x</code> is a reference to the trait object type <code>dyn Base</code>. A\n<em>trait object</em> is a little shim generated by the compiler that implements\nthe trait with the same name by forwarding all trait method calls to trait\nmethods of whatever type the trait object was created from. The forwarding\nis done by reading from a table of function pointers contained within the\ntrait object.</p>\n<pre><code class=\"language-rust\">// Generated by the compiler.\n//\n// This is an implementation of the trait `Base` for the\n// trait object type `dyn Base`, which you can think of as\n// a struct containing function pointers.\nimpl Base for (dyn Base) {\n    fn method(&amp;self) {\n        /*\n        Some automatically generated implementation detail\n        that ends up calling the right type's impl of the\n        trait method Base::method.\n        */\n    }\n}\n</code></pre>\n<p>In the quiz code, <code>x.method()</code> is a call to this automatically generated\nmethod whose fully qualified name is <code>&lt;dyn Base as Base&gt;::method</code>. Since <code>x</code>\nwas obtained by converting a <code>BothTraits</code> to <code>dyn Base</code>, the automatically\ngenerated implementation detail will wind up forwarding to <code>&lt;BothTraits as   Base&gt;::method</code> which prints <code>1</code>.</p>\n<p>Hopefully it's clear from all of this that nothing here has anything to do\nwith the unrelated trait method <code>Derived::method</code> defined by <code>BothTraits</code>.\nEspecially notice that <code>x.method()</code> cannot be a call to <code>Derived::method</code>\nbecause <code>x</code> is of type <code>dyn Base</code> and there is no implementation of\n<code>Derived</code> for <code>dyn Base</code>.</p>\n</li>\n<li>\n<p><code>static_dispatch(BothTraits)</code></p>\n<p>At compile time we know that <code>x.method()</code> is a call to <code>&lt;T as   Base&gt;::method</code>. Type inference within generic functions in Rust happens\nindependently of any concrete instantiation of the generic function i.e.\nbefore we know what <code>T</code> may be, other than the fact that it implements\n<code>Base</code>. Thus no inherent method on the concrete type <code>T</code> or any other trait\nmethod may affect what method <code>x.method()</code> is calling. By the time that <code>T</code>\nis decided, it has already been determined that <code>x.method()</code> is calling <code>&lt;T   as Base&gt;::method</code>.</p>\n<p>The generic function is instantiated with <code>T</code> equal to <code>BothTraits</code> so this\nis going to call <code>&lt;BothTraits as Base&gt;::method</code> which prints <code>1</code>.</p>\n</li>\n</ul>\n<p>If you are familiar with C++, the behavior of this code in Rust is <em>different</em>\nfrom the behavior of superficially analogous C++ code. In C++ the output would\nbe <code>22</code> as seen in the following implementation. This highlights the difference\nbetween Rust's traits and supertraits vs C++'s inheritance.</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nstruct Base {\n    virtual void method() const {\n        std::cout &lt;&lt; \"1\";\n    }\n};\n\nstruct Derived: Base {\n    void method() const {\n        std::cout &lt;&lt; \"2\";\n    }\n};\n\nvoid dynamic_dispatch(const Base &amp;x) {\n    x.method();\n}\n\ntemplate &lt;typename T&gt;\nvoid static_dispatch(const T x) {\n    x.method();\n}\n\nint main() {\n    dynamic_dispatch(Derived{});\n    static_dispatch(Derived{});\n}\n</code></pre>\n"
  },
  "28": {
    "code": "struct Guard;\n\nimpl Drop for Guard {\n    fn drop(&mut self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let _guard = Guard;\n    print!(\"3\");\n    let _ = Guard;\n    print!(\"2\");\n}\n",
    "difficulty": 1,
    "answer": "3121",
    "hint": "<p>A value is dropped when it no longer has an owner.</p>\n",
    "explanation": "<p>The program prints <code>3121</code>. That is, the <code>Drop</code> impl for <code>let _guard = Guard</code>\nruns at the end of main but the <code>Drop</code> impl for <code>let _ = Guard</code> runs right away.</p>\n<p>In general, a value is dropped when it no longer has an owner. The variable\n<code>_guard</code> owns the first value of type <code>Guard</code> and remains in scope until the end\nof main. The <code>_</code> is not a variable but a wildcard pattern that binds nothing;\nsince no variables are bound on this line, there is no variable to be the owner\nof the second value of type <code>Guard</code> and that value is dropped on the same line.</p>\n<p>This distinction between the underscore pattern vs variables with a leading\nunderscore is incredibly important to remember when working with lock guards in\nunsafe code.</p>\n<pre><code>use std::sync::Mutex;\n\nstatic MUTEX: Mutex&lt;()&gt; = Mutex::new(());\n\n/// MUTEX must be held when accessing this value.\nstatic mut VALUE: usize = 0;\n\nfn main() {\n    let _guard = MUTEX.lock().unwrap();\n    unsafe {\n        VALUE += 1;\n    }\n}\n</code></pre>\n<p>If this code were to use <code>let _ = MUTEX.lock().unwrap()</code> then the mutex guard\nwould be dropped immediately, releasing the mutex and failing to guard the\naccess of <code>VALUE</code>.</p>\n"
  },
  "29": {
    "code": "trait Trait {\n    fn p(&self);\n}\n\nimpl Trait for (u32) {\n    fn p(&self) { print!(\"1\"); }\n}\n\nimpl Trait for (i32,) {\n    fn p(&self) { print!(\"2\"); }\n}\n\nimpl Trait for (u32, u32) {\n    fn p(&self) { print!(\"3\"); }\n}\n\nimpl Trait for (i32, i32,) {\n    fn p(&self) { print!(\"4\"); }\n}\n\nfn main() {\n    (0).p();\n    (0,).p();\n    (0, 0).p();\n    (0, 0,).p();\n}\n",
    "difficulty": 1,
    "answer": "1244",
    "hint": "<p>A value in parentheses does not have the same type as a 1-tuple.</p>\n",
    "explanation": "<p>The trailing comma is required in the case of a 1-tuple, <code>(0,)</code>, because it\ndisambiguates it from <code>(0)</code> which is identical to <code>0</code>. However, for larger\ntuples, it is entirely optional: <code>(i32)</code> is a distinct type from <code>(i32,)</code>, but\n<code>(i32, i32)</code> and <code>(i32, i32,)</code> are the same.</p>\n<p>An integral literal <code>0</code> can be inferred to be any integer type, but defaults to\n<code>i32</code> if insufficient type information is available. <code>(0)</code> is inferred to be a\n<code>u32</code> and <code>(0,)</code> is inferred to be a <code>(i32,)</code> because those are respectively the\nonly integral and 1-tuple types with an implementation for <code>Trait</code>.</p>\n<p>Since <code>(0, 0)</code> and <code>(0, 0,)</code> have the same type, the output of their <code>p</code> methods\nmust be the same, but Rust needs to somehow choose between the two possible\nimplementations of <code>Trait</code>, namely <code>(u32, u32)</code> and <code>(i32, i32)</code>. Since <code>i32</code> is\nthe default integral type, <code>(i32, i32)</code> is chosen in both cases.</p>\n"
  },
  "30": {
    "code": "use std::rc::Rc;\n\nstruct A;\n\nfn p<X>(x: X) {\n    match std::mem::size_of::<X>() {\n        0 => print!(\"0\"),\n        _ => print!(\"1\"),\n    }\n}\n\nfn main() {\n    let a = &A;\n    p(a);\n    p(a.clone());\n    \n    let b = &();\n    p(b);\n    p(b.clone());\n    \n    let c = Rc::new(());\n    p(Rc::clone(&c));\n    p(c.clone());\n}\n",
    "difficulty": 1,
    "answer": "111011",
    "hint": "<p>Immutable pointers <code>&amp;T</code> and <code>Rc&lt;T&gt;</code> implement <code>Clone</code> even if <code>T</code> doesn't.</p>\n",
    "explanation": "<p>Both of our non-reference types, <code>()</code> and <code>A</code>, are zero-sized types (ZST). The\nfunction <code>p&lt;X&gt;</code> will print <code>0</code> if it is passed a value of type <code>X = ()</code> or <code>X = A</code>, and it will print <code>1</code> if passed a reference <code>X = &amp;()</code> or <code>X = &amp;A</code> regardless\nof exactly how big pointers happen to be.</p>\n<p><code>p(a)</code> invokes <code>p</code> with <code>X = &amp;A</code> because the argument <code>a</code> is of type <code>&amp;A</code>; this\nprints <code>1</code>.</p>\n<p>On the next line, if <code>A</code> implemented <code>Clone</code> then <code>a.clone()</code> would be a call to\nthat impl. But since it doesn't, the compiler finds another applicable impl\nwhich is the implementation of <code>Clone</code> for references <code>&amp;T</code> -- so concretely the\nclone call is calling the impl of <code>Clone</code> for <code>&amp;A</code> which turns a <code>&amp;&amp;A</code> into a\n<code>&amp;A</code> by simply duplicating the reference. We get another call to <code>p</code> with <code>X = &amp;A</code> printing <code>1</code>. The impl of <code>Clone</code> for references is useful in practice when\na struct containing a reference wants to derive <code>Clone</code>, but as seen here it can\nsometimes kick in unexpectedly.</p>\n<p>The type <code>()</code> <em>does</em> implement <code>Clone</code> so <code>b.clone()</code> invokes that impl and\nproduces <code>()</code>. The implementation of <code>Clone</code> for <code>&amp;()</code> would also be applicable\nas happened in the case of <code>A</code>, but the compiler prefers calling the trait impl\nfor <code>()</code> which converts <code>&amp;()</code> to <code>()</code> over the trait impl for <code>&amp;()</code> which\nconverts <code>&amp;&amp;()</code> to <code>&amp;()</code> because the former is the one that requires fewer\nimplicit references or dereferences inserted by the trait solver. In the call to\n<code>b.clone()</code>, <code>b</code> is of type <code>&amp;()</code> which exactly matches the argument of the impl\n<code>Clone</code> for <code>()</code>, while in order to obtain a <code>&amp;&amp;()</code> to pass as argument to the\nimpl <code>Clone</code> for <code>&amp;()</code> the trait solver would need to insert an additional layer\nof referencing implicitly -- effectively computing <code>(&amp;b).clone()</code>.</p>\n<p>What we get is <code>p(b)</code> calling <code>p</code> with <code>X = &amp;()</code> and <code>p(b.clone())</code> calling <code>p</code>\nwith <code>X = ()</code>. Together these print <code>10</code>.</p>\n<p>Finally in the <code>Rc</code> case, both calls to <code>p</code> are with <code>X = Rc&lt;()&gt;</code> which is\nnon-zero sized. It is considered idiomatic to clone a <code>Rc</code> using <code>Rc::clone(&amp;c)</code>\ninstead of <code>c.clone()</code> because it makes it apparent that this is a reference\ncount bump rather than cloning underlying data, but ultimately both refer to the\nsame function. To call the <code>clone</code> method of a value inside a <code>Rc</code>, you would\nneed to dereference it first: <code>(*c).clone()</code>.</p>\n"
  },
  "31": {
    "code": "trait Or {\n    fn f(self);\n}\n\nstruct T;\n\nimpl Or for &T {\n    fn f(self) {\n        print!(\"1\");\n    }\n}\n\nimpl Or for &&&&T {\n    fn f(self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    let t = T;\n    let wt = &T;\n    let wwt = &&T;\n    let wwwt = &&&T;\n    let wwwwt = &&&&T;\n    let wwwwwt = &&&&&T;\n    t.f();\n    wt.f();\n    wwt.f();\n    wwwt.f();\n    wwwwt.f();\n    wwwwwt.f();\n}\n",
    "difficulty": 2,
    "answer": "111222",
    "hint": "<p>During a method lookup, Rust automatically derefences and borrows the receiver\nin a well-defined order until it finds the first function with a suitable\nsignature. What is that order?</p>\n",
    "explanation": "<p>The <a target=\"_blank\" href=\"https://doc.rust-lang.org/reference/expressions/method-call-expr.html\">Reference</a> describes Rust's method lookup order. The relevant\nparagraph is:</p>\n<blockquote>\n<p>Obtain [the candidate receiver type] by repeatedly dereferencing the receiver\nexpression's type, adding each type encountered to the list, then finally\nattempting an unsized coercion at the end, and adding the result type if that\nis successful. Then, for each candidate <code>T</code>, add <code>&amp;T</code> and <code>&amp;mut T</code> to the\nlist immediately after <code>T</code>.</p>\n</blockquote>\n<p>Applying these rules to the given examples, we have:</p>\n<ul>\n<li><code>t.f()</code>: We try to find a function <code>f</code> defined on the type <code>T</code>, but there is\nnone. Next, we search the type <code>&amp;T</code>, and find the first implementation of the\n<code>Or</code> trait, and we are done. Upon invocation, the resolved call prints <code>1</code>.</li>\n<li><code>wt.f()</code>: We search for a function <code>f</code> defined on <code>&amp;T</code>, which immediately\nsucceeds. Upon invocation, the function prints <code>1</code>.</li>\n<li><code>wwt.f()</code>: The search order is <code>&amp;&amp;T</code> -&gt; <code>&amp;&amp;&amp;T</code> -&gt; <code>&amp;mut &amp;&amp;T</code> -&gt; <code>&amp;T</code>, and\nwe're done. Upon invocation, the function prints <code>1</code>.</li>\n<li><code>wwwt.f()</code>: <code>&amp;&amp;&amp;T</code> -&gt; <code>&amp;&amp;&amp;&amp;T</code>. This prints <code>2</code>.</li>\n<li><code>wwwwt.f()</code>: <code>&amp;&amp;&amp;&amp;T</code>. This prints <code>2</code>.</li>\n<li><code>wwwwwt.f()</code>: <code>&amp;&amp;&amp;&amp;&amp;T</code> -&gt; <code>&amp;&amp;&amp;&amp;&amp;&amp;T</code> -&gt; <code>&amp;mut &amp;&amp;&amp;&amp;&amp;T</code> -&gt; <code>&amp;&amp;&amp;&amp;T</code>. This prints\n<code>2</code>.</li>\n</ul>\n"
  },
  "32": {
    "code": "fn check(x: i32) -> bool {\n    print!(\"{}\", x);\n    false\n}\n\nfn main() {\n    match (1, 2) {\n        (x, _) | (_, x) if check(x) => {\n            print!(\"3\")\n        }\n        _ => print!(\"4\"),\n    }\n}\n",
    "difficulty": 2,
    "answer": "124",
    "hint": "<p>Either way would be confusing in different situations; there isn't a clear right\nbehavior that a hint could help identify. Guess both. :/</p>\n",
    "explanation": "<p>This question covers two behaviors of <code>match</code> arms and guards.</p>\n<p>First, whether an <code>if</code> guard on a match-arm containing <code>|</code> applies to <em>all</em>\nalternatives in the match-arm or just to the one it is adjacent to. In the quiz\ncode, does <code>check(x)</code> execute at all for <code>(x, _)</code> or does it only cover the <code>(_, x)</code> case? We would expect <code>1</code> would get printed if and only if the former is the\ncase. In fact <code>1</code> does get printed. A match-arm gets to have at most one <code>if</code>\nguard and that guard applies to all the <code>|</code>-separated alternatives in the arm.</p>\n<p>But second, this question also covers a kind of \"backtracking\" behavior of\nmatch-arms. After <code>check(x)</code> returns false on <code>(x, _)</code>, does the whole match-arm\nfail to match at that point or does Rust move on to <code>(_, x)</code> and execute the\nguard a second time? We would expect <code>2</code> to be printed if and only if the latter\nis the case. In fact <code>2</code> does get printed; the guard is being run multiple\ntimes, once per <code>|</code>-separated alternative in the match-arm.</p>\n"
  },
  "33": {
    "code": "use std::ops::RangeFull;\n\ntrait Trait {\n    fn method(&self) -> fn();\n}\n\nimpl Trait for RangeFull {\n    fn method(&self) -> fn() {\n        print!(\"1\");\n        || print!(\"3\")\n    }\n}\n\nimpl<F: FnOnce() -> T, T> Trait for F {\n    fn method(&self) -> fn() {\n        print!(\"2\");\n        || print!(\"4\")\n    }\n}\n\nfn main() {\n    (|| .. .method())();\n}\n",
    "difficulty": 3,
    "answer": "24",
    "hint": "<p><code>||</code> is a closure introducer. <code>..</code> is range syntax, normally seen in slicing\noperations like <code>&amp;s[1..4]</code> or <code>&amp;s[..s.len() - 1]</code>.</p>\n",
    "explanation": "<p>The two rational possibilities are <code>1</code> or <code>24</code>, depending on how the precedence\nof <code>|| .. .method()</code> is disambiguated.</p>\n<ul>\n<li>\n<p>As <code>|| ((..).method())</code>, which is a closure whose body invokes our impl of\n<code>Trait</code> on <code>RangeFull</code>. In this case <code>main</code> would print <code>1</code>. It would <em>not</em>\nprint <code>13</code> because the <code>fn()</code> returned from <code>(..).method()</code> is never invoked\nby <code>main</code>.</p>\n</li>\n<li>\n<p>As <code>(|| ..).method()</code>, which is an invocation of our impl of <code>Trait</code> on\n<code>FnOnce() -&gt; T</code> where <code>T</code> is inferred to be <code>RangeFull</code>. In this case <code>main</code>\nwould print <code>24</code>.</p>\n</li>\n</ul>\n<p>The latter of those is the correct answer.</p>\n<p>We can achieve the former behavior by explicitly parenthesizing as shown in the\nbullet above.</p>\n<p>Partially parenthesizing as <code>|| (.. .method())</code> is not sufficient. This results\nin a parse error.</p>\n<pre><code>error: expected one of `)` or `,`, found `.`\n  --&gt; src/main.rs:22:13\n   |\n22 |     (|| (.. .method()))();\n   |            -^ expected one of `)` or `,`\n   |            |\n   |            help: missing `,`\n</code></pre>\n<p>Correctly handling a quite ambiguous expression like <code>|| .. .method()</code> is a\nchallenge for tooling, as seen by the associated bugs in Rustfmt\n(<a target=\"_blank\" href=\"https://github.com/rust-lang/rustfmt/issues/4808\">rust-lang/rustfmt#4808</a>) and Syn (<a target=\"_blank\" href=\"https://github.com/dtolnay/syn/issues/1019\">dtolnay/syn#1019</a>).</p>\n"
  },
  "34": {
    "code": "fn d<T>(_f: T) {\n    match std::mem::size_of::<T>() {\n        0 => print!(\"0\"),\n        1 => print!(\"1\"),\n        _ => print!(\"2\"),\n    }\n}\n\nfn a<T>(f: fn(T)) {\n    d(f);\n}\n\nfn main() {\n    a(a::<u8>);\n    d(a::<u8>);\n}\n",
    "difficulty": 2,
    "answer": "20",
    "hint": "<p>The answer would be the same with any other integer type in place of <code>u8</code>.</p>\n",
    "explanation": "<p>The expression <code>a::&lt;u8&gt;</code>'s type is a zero-sized type (ZST).</p>\n<p>Rust's implementation choices around function types are different from nearly\nall other languages, but are an important enabler of many of Rust's\nzero-overhead abstractions. In Rust, every function (or every distinct\ninstantiation of a generic function) has its own unique type. In particular,\neven two functions with the same function signature would have different types.</p>\n<p>Having a unique type for each function allows the type itself to carry the\ninformation of what function will be called, not needing any runtime state such\nas a pointer.</p>\n<p>To understand the optimization advantages of this approach, consider\n<code>Iterator::map</code> and the two calls <code>iter.map(f)</code> and <code>iter.map(g)</code> where <code>f</code> and\n<code>g</code> are different functions with the same signature. Because <code>f</code> and <code>g</code> have\ndistinct types, the two <code>map</code> calls would produce two different monomorphic\ninstantiations of the generic <code>map</code> function, one of which statically calls <code>f</code>\nand the other statically calls <code>g</code>, as if you had directly written a\nspecial-purpose map implementation specific to each function without the\nabstraction provided by <code>map</code>. The generic <code>map</code> is thus a zero-overhead\nabstraction. Traditionally in other languages such as C++ or Go, in this\nsituation <code>f</code> and <code>g</code> would be passed to <code>map</code> as a function pointer and there\nwould be just one instantiation of <code>map</code>, containing a dynamic dispatch to\nexecute the function call, which is usually going to be slower than statically\ncalling the right function. This performance penalty makes <code>map</code> in those\nlanguages not a zero-overhead abstraction.</p>\n<p>Currently in Rust there is no syntax to express the type of a specific function,\nso they are always passed as a generic type parameter with a <code>FnOnce</code>, <code>Fn</code> or\n<code>FnMut</code> bound. In error messages you might see function types appear in the\nform <code>fn(T) -&gt; U {fn_name}</code>, but you can't use this syntax in code.</p>\n<p>On the other hand, a function pointer, <code>fn(T) -&gt; U</code>, is pointer-sized at\nruntime. Function types can be coerced into function pointers, which can be\nuseful in case you need to defer the choice of function to call until runtime.</p>\n<p>In the quiz code, the first call in <code>main</code> coerces <code>a::&lt;u8&gt;</code> from a function to\na function pointer (<code>fn(fn(u8)) {a::&lt;u8&gt;}</code> to <code>fn(fn(u8))</code>) prior to calling\n<code>d</code>, so its size would be 8 on a system with 64-bit function pointers. The\nsecond call in <code>main</code> does not involve function pointers; <code>d</code> is directly called\nwith <code>T</code> being the inexpressible type of <code>a::&lt;u8&gt;</code>, which is zero-sized.</p>\n"
  },
  "35": {
    "code": "macro_rules! x {\n    ($n:expr) => {\n        let a = X($n);\n    };\n}\n\nstruct X(u64);\n\nimpl Drop for X {\n    fn drop(&mut self) {\n        print!(\"{}\", self.0);\n    }\n}\n\nfn main() {\n    let a = X(1);\n    x!(2);\n    print!(\"{}\", a.0);\n}\n",
    "difficulty": 1,
    "answer": "121",
    "hint": "<p>There are some programs for which <code>cargo expand</code> produces expanded code that\ncompiles, but behaves differently than the original code with the original macro\nhygiene.</p>\n",
    "explanation": "<p>There are two reasonable paths to an incorrect answer on this question, based on\nyour assumptions around how this macro gets expanded:</p>\n<ol>\n<li><code>let a = X(2);</code></li>\n<li><code>{ let a = X(2); }</code></li>\n</ol>\n<p>If the first expansion were right, the macro would introduce a new binding, <code>a</code>,\nwhich shadows the <code>a</code> already directly assigned in <code>main</code>. So the print\nstatement in <code>main</code> would execute first, printing <code>2</code>, then the variables would\ndrop in reverse order of introduction, printing <code>2</code> then <code>1</code>, with a final\noutput of <code>221</code>.</p>\n<p>If the second expansion were right, the macro would introduce <code>a</code> in a nested\nscope, shadowing the already existing <code>a</code> only inside of that scope and not\nbeyond it. Since the new <code>a</code>'s scope ends before the print statement, its <code>Drop</code>\nimpl when going out of scope would be the first print to execute, printing <code>2</code>.\nNext the print in <code>main</code> would print <code>1</code> which is the value of the first <code>a</code>,\nand finally <code>1</code> again when that value drops at the end of <code>main</code>, with final\noutput <code>211</code>.</p>\n<p>If you've read about macro hygiene then you might have guessed it would be\nimplemented something like this second option. It's important that internals of\na macro don't interfere coincidentally with variables in scope at the call site,\nand Rust macros mostly do a good job of preventing unintended name collisions.\nHowever, this is not how hygiene is implemented; introducing artificial scopes\naround macro expansions would make them more limited in their usefulness, and\nwouldn't solve a lot of other hygiene problems.</p>\n<p>You can instead imagine hygiene as a way of assigning a color to each mention of\nthe name of a local variable, allowing for there to be multiple distinguishable\nlocal variables in scope simultaneously with the same textual name.</p>\n<pre><code>fn main() {\n    let <b style=\"background-color:mediumpurple;color:white\">a</b> = X(1);\n    let <b style=\"background-color:coral;color:white\">a</b> = X(2);\n    print!(\"{}\", <b style=\"background-color:mediumpurple;color:white\">a</b>.0);\n}</code></pre>\n<p>So what's printed is the value of <code>main</code>'s identifier\n<code><b style=\"background-color:mediumpurple;color:white\">a</b></code>\nwhich is <code>1</code>, then the two values are dropped in reverse order of introduction\nprinting <code>2</code> then <code>1</code>, and the output of the program is <code>121</code>.</p>\n"
  },
  "36": {
    "code": "fn call(mut f: impl FnMut() + Copy) {\n    f();\n}\n\nfn g(mut f: impl FnMut() + Copy) {\n    f();\n    call(f);\n    f();\n    call(f);\n}\n\nfn main() {\n    let mut i = 0i32;\n    g(move || {\n        i += 1;\n        print!(\"{}\", i);\n    });\n}\n",
    "difficulty": 1,
    "answer": "1223",
    "hint": "<p>The variable <code>i</code> is captured by value in the compiler-generated closure object.</p>\n",
    "explanation": "<p>The object passed into <code>g</code> is a <code>FnMut</code> closure which captures an integer by\nvalue. Effectively it's an unnameable struct containing a single field whose\ntype is <code>i32</code>, with a function call operator that takes <code>&amp;mut self</code>:</p>\n<pre><code class=\"language-rust\">#[derive(Copy, Clone)]\npub struct UnnameableClosure {\n    i: i32,\n}\n\nimpl UnnameableClosure {\n    pub fn unnameable_call_operator(&amp;mut self) {\n        self.i += 1;\n        print!(\"{}\", self.i);\n    }\n}\n\nlet mut i = 0i32;\ng(UnnameableClosure { i });\n</code></pre>\n<p>The behavior of the 4 calls inside <code>g</code> is as follows:</p>\n<ul>\n<li>\n<p><code>f()</code> runs the closure and its by-value captured value of <code>i</code> becomes 1.</p>\n</li>\n<li>\n<p><code>call(f)</code> makes a <strong>copy</strong> of <code>f</code> to become the argument of <code>call</code>. The copy\ngets executed and its <code>i</code> becomes 2, but the original closure still holds a\nvalue of 1 for its captured <code>i</code>. The copy of the closure gets dropped as it\ngoes out of scope at the end of the body of <code>call</code>.</p>\n</li>\n<li>\n<p><code>f()</code> runs the original closure a second time and its <code>i</code> becomes 2.</p>\n</li>\n<li>\n<p><code>call(f)</code> copies <code>f</code> a second time and executes the copy, its <code>i</code> becomes 3.</p>\n</li>\n</ul>\n<p>Since Rust 1.26, closures automatically implement <code>Clone</code> if all their captures\nimplement <code>Clone</code>, and <code>Copy</code> if all the captures implement <code>Copy</code>.</p>\n<p>If the <code>move</code> keyword were omitted from the quiz code, the compiler-generated\nclosure would capture <code>i</code> by mutable reference instead of by value:</p>\n<pre><code class=\"language-rust\">pub struct UnnameableClosure&lt;'a&gt; {\n    i: &amp;'a mut i32,\n}\n</code></pre>\n<p>and there would no longer be a <code>Copy</code> impl, because it's incorrect to duplicate\na mutable reference into multiple copies (aliasing xor mutation; this is the\npoint of the borrow checker).</p>\n<p>One recurring source of confusion for Rust beginners is the relationship between\n<code>move</code> and non-<code>move</code> closures vs <code>Fn</code> and <code>FnMut</code> and <code>FnOnce</code> closures. These\nare two nearly-orthogonal things. As illustrated in the <code>UnnameableClosure</code>\npseudocode above, <code>move</code> vs non-<code>move</code> is about whether the <em>fields</em> of the\ncompiler-generated closure struct have the same type as the original captured\nvariable's type, vs are references to the original captured variable's type\n(<code>i32</code> vs <code>&amp;mut i32</code>, for example). In contrast, <code>Fn</code> vs <code>FnMut</code> vs <code>FnOnce</code> is\nabout whether the <em>call method</em> of the compiler-generated closure struct has a\nreceiver which is <code>&amp;self</code> vs <code>&amp;mut self</code> vs <code>self</code>.</p>\n"
  },
  "37": {
    "code": "struct Drop0;\nimpl Drop for Drop0 {\n    fn drop(&mut self) {\n        print!(\"0\");\n    }\n}\n\nfn main() {\n    {\n        let _ = &Drop0;\n        print!(\"1\");\n    }\n    {\n        _ = &Drop0;\n        print!(\"1\");\n    }\n}\n",
    "difficulty": 2,
    "answer": "1001",
    "hint": "<p><code>let</code> is a statement, while assignment is an expression.</p>\n",
    "explanation": "<p>When <code>Drop0</code> is created, in both cases, it's assigned to a <a target=\"_blank\" href=\"https://doc.rust-lang.org/stable/reference/expressions.html#temporaries\">temporary</a> memory\nlocation. Temporary memory locations are normally <a target=\"_blank\" href=\"https://doc.rust-lang.org/stable/reference/destructors.html#r-destructors.scope.temporary\">scoped</a> to the statement\nwhere they're created, so the value is dropped at the end of the statement\nunless it's moved to a new location.</p>\n<p>In the <a target=\"_blank\" href=\"https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html?highlight=destructuring#r-expr.assign.destructure\">assignment</a> statement, <code>_ = &amp;Drop0</code>, the <a target=\"_blank\" href=\"https://doc.rust-lang.org/stable/reference/expressions/underscore-expr.html?highlight=underscore#_-expressions\">underscore\nexpression</a> <code>_</code>, is used to ignore the binding, therefore not moving\nthe value, and it ends up being dropped at the end of the statement. So, <code>0</code> is\nprinted first then <code>1</code>.</p>\n<p>In contrast, with <code>let</code> statements, <a target=\"_blank\" href=\"https://doc.rust-lang.org/stable/reference/destructors.html#temporary-lifetime-extension\">temporary lifetime extension</a> can take\nplace and extend the lifetime of the temporary until the end of the block\ncontaining the <code>let</code>. For <code>Drop0</code>, in the statement <code>let _ = &amp;Drop0</code>, this\nhappens because it's the <a target=\"_blank\" href=\"https://doc.rust-lang.org/stable/reference/destructors.html#r-destructors.scope.lifetime-extension.exprs\">operand of a borrow expression</a>. So even if\nthe value itself doesn't move, the lifetime of the temporary is extended until\nthe end of the block and so <code>1</code> is printed first then <code>0</code>.</p>\n"
  }
};
